<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yihang</title>
  
  <subtitle>Have a nice day!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yihang-li.github.io/"/>
  <updated>2021-03-30T07:22:54.116Z</updated>
  <id>https://yihang-li.github.io/</id>
  
  <author>
    <name>Yihang Li</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SGD 和它的兄弟们</title>
    <link href="https://yihang-li.github.io/2021/03/21/Optimization%20for%20Training%20Deep%20Models/"/>
    <id>https://yihang-li.github.io/2021/03/21/Optimization%20for%20Training%20Deep%20Models/</id>
    <published>2021-03-21T12:57:33.248Z</published>
    <updated>2021-03-30T07:22:54.116Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SGD-和它的兄弟们"><a href="#SGD-和它的兄弟们" class="headerlink" title="SGD 和它的兄弟们"></a>SGD 和它的兄弟们</h2><p><code>Batch Gradient Descent</code>（正常的梯度下降）正常下山</p><p><code>SGD</code> 用单个训练样本的损失来近似平均损失    蒙着眼睛下山 （害怕山谷（震荡）和鞍点（停滞））</p><p><code>Mini-Batch SGD</code> 为了降低随机梯度的方差，使得迭代算法更加稳定，也为了充分利用高度优化的矩阵运算操作，同时处理若干个（一个小批量）的数据</p><a id="more"></a><p>改进随机梯度下降法：<code>惯性保持</code> <code>环境感知</code></p><p><code>Momentum</code> ： 惯性的获得是基于历史信息 （SGD在山谷震荡、鞍点停止，而加上惯性之后，有助于打破这一困境）</p><script type="math/tex; mode=display">v_t = \gamma v_{t-1} + \eta g_t</script><script type="math/tex; mode=display">\theta_{t+1} = \theta_t - v_t</script><p>前进步伐$-v_t$由两部分组成：一是学习率$\eta$乘以当前估计的梯度$g_t$；二是带衰减的前一次步伐$v_{t-1}$</p><p><code>AdaGrad</code>:  感知环境才能更好地前进 (根据自变量在每个维度的梯度值大小来调整各个维度上的学习率，从而避免统一的学习率难以适应所有维度的问题)</p><p>分量形式：</p><script type="math/tex; mode=display">\theta_{t+1, i} = \theta_{t, i} - \frac{\eta}{\sqrt{\sum_{k=0}^{t}g_{k,i}^2+\epsilon}}g_{t,i}</script><p>其中$\theta_{t+1,i}$表示t+1时刻的参数向量$\theta_{t+1}$的第i个参数，$g_{k,i}$表示k时刻的梯度向量$g_k$的第i个维度（方向）</p><p>向量形式：</p><script type="math/tex; mode=display">s_t = s_{t-1} + g_t \odot g_t</script><script type="math/tex; mode=display">\theta_t = \theta_{t-1} - \frac{\eta}{\sqrt{s_t+\epsilon}}\odot g_t</script><p>其中$\odot$表示按元素相乘，$\eta$是学习率，$\epsilon$是为了维持数值稳定性而添加的常数，这里开方、除法、乘法的运算都是按元素运算的</p><p><code>RMSProp</code>： 学会放下，以后才能更好的拿起   (Adagrad + forgetting, Adagrad 一直在按元素累加过去梯度的平方，始终不肯放下，导致在迭代后期学习率过小，可能较难找到一个有用的解，RMSProp学会了放下，带来了改进)</p><script type="math/tex; mode=display">s_t = \gamma s_{t-1} + (1-\gamma)g_t \odot g_t</script><script type="math/tex; mode=display">\theta_t = \theta_{t-1} - \frac{\eta}{\sqrt{s_t+\epsilon}}\odot g_t</script><p>因为RMSProp算法的状态变量是对平方项$g_t\odot g_t$的指数加权移动平均，所以可以看作最近$\frac{1}{1-\gamma}$个时间步的小批量随机梯度平方项的加权平均。这样就使得自变量每个元素的学习率在迭代过程中就不再一直降低（或不变）</p><p>注：RMSProp源自Coursera上Hinton的一门课</p><p>（<code>AdaDelta</code>：参加D2L（没有学习率超参数，通过使用有关自变量更新量平方的指数加权移动平均的项来替代RMSProp算法中的学习率））</p><p><code>Adam</code>：历史、环境，我都要！（RMSProp + Momentum）</p><script type="math/tex; mode=display">v_t = \beta_1 v_{t-1} + (1-\beta_1) g_t</script><script type="math/tex; mode=display">s_t = \beta_2 s_{t-1} + (1-\beta_2)g_t \odot g_t</script><script type="math/tex; mode=display">\theta_t = \theta_{t-1} - \frac{\eta}{\sqrt{s_t+\epsilon}}\odot v_t</script><p>注：还有偏差修正：参见D2L</p><p>【参考】</p><ol><li><a href="https://www.youtube.com/watch?v=OP5HcXJg2Aw">李宏毅</a></li><li><a href="https://d2l.ai/chapter_convolutional-neural-networks/conv-layer.html">D2L</a></li><li>花书</li><li>百面机器学习</li><li>百面深度学习</li><li>课件</li></ol><p>Note：Vanilla 一般的</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SGD-和它的兄弟们&quot;&gt;&lt;a href=&quot;#SGD-和它的兄弟们&quot; class=&quot;headerlink&quot; title=&quot;SGD 和它的兄弟们&quot;&gt;&lt;/a&gt;SGD 和它的兄弟们&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Batch Gradient Descent&lt;/code&gt;（正常的梯度下降）正常下山&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SGD&lt;/code&gt; 用单个训练样本的损失来近似平均损失    蒙着眼睛下山 （害怕山谷（震荡）和鞍点（停滞））&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Mini-Batch SGD&lt;/code&gt; 为了降低随机梯度的方差，使得迭代算法更加稳定，也为了充分利用高度优化的矩阵运算操作，同时处理若干个（一个小批量）的数据&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Notes" scheme="https://yihang-li.github.io/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>算法相关知识点总结</title>
    <link href="https://yihang-li.github.io/2021/03/13/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>https://yihang-li.github.io/2021/03/13/%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-13T08:18:37.460Z</published>
    <updated>2021-03-30T07:32:29.665Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="模型评估"><a href="#模型评估" class="headerlink" title="模型评估"></a>模型评估</h2><h3 id="分类准确率"><a href="#分类准确率" class="headerlink" title="分类准确率"></a>分类准确率</h3><blockquote><p>分类正确的样本占总样本的比例：(等价于0-1 损失)</p><script type="math/tex; mode=display">\text{Accuracy} = \frac{n_{\text{correct}}}{n_{\text{total}}}</script><p>缺点：当数据标签失衡时，占比大的类别往往成为影响准确率的最主要因素</p></blockquote><p>解决：改用平均准确率，即每个类别下的样本准确率的算术平均</p><h3 id="精确率与召回率（Precision-amp-Recall）"><a href="#精确率与召回率（Precision-amp-Recall）" class="headerlink" title="精确率与召回率（Precision &amp; Recall）"></a>精确率与召回率（Precision &amp; Recall）</h3><blockquote><p>精确率是指分类正确的正样本个数(TP)占分类器判定为正样本的样本个数(TP+FP)的比例: $\frac{TP}{TP+FP}$<br>召回率是指分类正确的正样本个数(TP)占真正的正样本个数(TP + FN)的比例: $\frac{TP}{TP+FN}$<br>Precision 和 Recall 之间往往存在一个权衡，它们通常用来衡量一个排序模型的性能<br>为了综合评估一个排序模型的好坏，最好绘制出模型的P-R曲线<br>它上面的一个点代表在某一阈值下，模型将大于该阈值的结果判定为正样本，小于该阈值的结果判定为负样本，此时返回结果对应的Recall 和 Precision<br>整条P-R曲线是通过将阈值从高到低移动而生成的<br>只用某个点对应的精确率和召回率是不能全面衡量模型性能的，只有通过P-R曲线的整体表现才能对模型进行更为全面的评估</p></blockquote><h3 id="F1-score"><a href="#F1-score" class="headerlink" title="F1-score"></a>F1-score</h3><blockquote><p>精确率和召回率的调和平均值：</p><script type="math/tex; mode=display">\text{F1-score} =\frac{2}{\text{precision}^{-1}+\text{recall}^{-1}} = 2\cdot\frac{\text{precision}\times\text{recall}}{\text{precision} + \text{recall}} = \frac{TP}{TP+\frac{1}{2}(FN+FP)}</script></blockquote><p>&gt;</p><blockquote><p>综合地反应一个排序模型的性能</p></blockquote><h3 id="ROC曲线-AUC值"><a href="#ROC曲线-AUC值" class="headerlink" title="ROC曲线, AUC值"></a>ROC曲线, AUC值</h3><blockquote><p>ROC曲线：横坐标为假阳性率（$\text{FPR}=\frac{FP}{N}$），纵坐标为真阳性率($\text{TPR}=\frac{TP}{P}$)<br>ROC曲线是通过不断移动分类器的截断点（区分正负预测结果的阈值）来生成曲线上的一组关键点的<br>当截断点选择为正无穷，即模型把样本全部预测为负类，那么FP和TP都为0，相应的FPR和TPR都为0，因此曲线的第一个点的坐标就是（0，0），其余同理</p><p>AUC值：ROC曲线下的面积大小，量化基于ROC曲线衡量出的模型性能。<br>既然是面积，那就只需要沿着ROC的横轴积分就可以了<br>ROC曲线一般都处于y=x这条直线上方（如果不是，只需把模型预测概率反转成1-p就可以得到更好的分类器），因此AUC的值一般在0.5～1之间，<br>AUC越大，说明分类器越可能把真正的正样本排在前面，分类性能越好<br>另一个定义：随机给定一个正样本和一个负样本，分类器输出该正样本为正的那个概率值 比 分类器输出该负样本为正的那个概率值 要大的可能性，此时有显示表达式：$\frac{\sum I(P_{\text{正样本}}， P_{\text{负样本}})}{M\times N}$, $I(P_{\text{正样本}}， P_{\text{负样本}}) = 1 \quad \text{if} \quad P_{\text{正样本}} &gt; P_{\text{负样本}}, 0.5 \quad \text{elif} \quad P_{\text{正样本}} = P_{\text{负样本}} $ else 0</p><p>当正负样本的分布发生变化时，ROC曲线的形状基本保持不变，而P-R曲线的形状一般会剧烈变化，因此ROC曲线能更稳定地反映模型本身的好坏。</p></blockquote><h3 id="RMSE"><a href="#RMSE" class="headerlink" title="RMSE"></a>RMSE</h3><blockquote><p>常用来衡量回归模型的好坏：$\text{RMSE} = \sqrt{\frac{\sum_{i=1}^{n}(y_i-\hat{y_i})^2}{n}}$</p><p>Outlier 会让RMSE指标变得很差<br>解决办法：</p><ol><li>如果认定这些离群点是噪声点，降噪处理；</li><li>如果不认为是噪声点，需要在建模的时候考虑相应机制来提高模型的预测能力，这里比较复杂；</li><li>更换更合适的指标，比如平均绝对百分比误差MAPE，它把每个点的误差进行了归一化，降低了离群点带来的绝对误差的影响：$\text{MAPE} = \sum_{i=1}^{n}|\frac{y_i - \hat{y_i}}{y_i}|\times\frac{100}{n}$</li></ol></blockquote><h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><h3 id="Least-Square"><a href="#Least-Square" class="headerlink" title="Least Square"></a>Least Square</h3><blockquote><p>有闭形式的解：$(X^{\top}X)^{-1}X^{\top}y$ （当括号内可逆时）</p></blockquote><h3 id="Ridege"><a href="#Ridege" class="headerlink" title="Ridege"></a>Ridege</h3><blockquote><p>$L_2$正则化<br>也有闭形式的解：$(X^{\top}X + \lambda I)^{-1}X^{\top}y$ （适当的$\lambda$使得括号内一定可逆）</p></blockquote><h3 id="Lasso"><a href="#Lasso" class="headerlink" title="Lasso"></a>Lasso</h3><blockquote><p>$L_1$正则化，稀疏性，不可求梯度<br>求解：Proximal Gradient Descent （= proximal point + gradient descent）分成可以求梯度和不可以求梯度的两部分，对于前者用线性近似，后者用函数本身, 得到新的目标函数之后，分解，对求和中的每一项分别求最小，就可以得到相应的参数对应的分量的迭代表达式，而且是闭形式的</p><h3 id="P-Value"><a href="#P-Value" class="headerlink" title="P-Value"></a>P-Value</h3><p>给定原假设和备择假设，在假定原假设成立的情况下，构造相应的检验统计量，计算出对应的P-value，如果P-value很小，低于我们预先给定的显著性水平，说明小概率事件发生了，而现实中小概率事件发生往往是不太可能的，所以我们应该拒绝原假设，接受备择假设</p></blockquote><p>P-Value不用于证明任何事情。、<strong>当结果具有统计学意义时，p值将用作质疑我们最初假设（无效假设）的工具</strong></p><h2 id="传统机器学习算法"><a href="#传统机器学习算法" class="headerlink" title="传统机器学习算法"></a>传统机器学习算法</h2><h3 id="决策树-（DT）"><a href="#决策树-（DT）" class="headerlink" title="决策树 （DT）"></a>决策树 （DT）</h3><blockquote><p>自上而下，对样本数据进行树形分类的过程。（简单直观，解释性强）<br>结点+有向边构成：每个内部结点表示一个特征，叶结点表示类别<br>将决策树应用集成学习的思想可以得到随机森林，梯度提升决策树（GBDT）等模型<br>决策树的生成：特征选择，树的构造，树的剪枝</p><p>常用的决策树算法</p><p>ID3：最大信息增益。<br>对于样本集合D, 类别数为K，数据集D的经验熵表示为：$H(D)=-\sum_{k=1}^{K}\frac{|C_k|}{|D|}log_2 \frac{|C_k|}{|D|}$, 其中$C_k$是样本集合D中属于第K类的样本子集<br>某个特征A对于数据集D的经验条件熵为：$H(D|A)=\sum_{i=1}^{n}\frac{|D_i|}{D}H(D_i)=\sum_{i=1}^{n}\frac{|D_i|}{D}(-\sum_{k=1}^{K}\frac{|D_{ik}|}{D_i}log_2 \frac{|D_{ik}|}{D_i})$, 其中，$D_i$表示D中特征A取第i个值的样本子集，$D_{ik}$表示$D_i$中属于第k类的样本子集<br>信息增益：$g(D,A) = H(D) - H(D|A)$, 优先选择信息增益最大的特征</p><p>C4.5：最大信息增益比。<br>特征A对于数据集D的信息增益比：$g_R (D,A) = \frac{g(D,A)}{H_A(D)}$, 其中，$H_A (D) = -\sum_{i=1}^{n}\frac{|D_i|}{D} log_2 \frac{|D_i|}{D}$，称为数据集D关于A的取值熵</p><p>CART：最大基尼系数（Gini）<br>Gini描述的是数据的纯度，与信息熵含义类似：$\text{Gini}(D)= 1 - \sum_{k=1}^{n}(\frac{|C_k|}{|D|})^2$<br>每一次迭代中选取Gini指数最小的特征及其对应的切分点进行分类<br>  与ID3，C4.5不同的是，CART是一颗二叉树，采用二元切割法，每一步将数据按特征A的取值切成两份，分别进入左右子树，特征A的Gini指    数定义为$\text{Gini}(D|A)=\sum_{i=1}^{n}\frac{|D_i|}{|D|}Gini(D_i)$</p><p>ID3 会倾向于取值较多的特征<br>C4.5是对ID3的优化，通过引入信息增益比，在一定程度上对取值较多的特征进行惩罚，避免ID3出现过拟合的特性，提升决策树的泛化能力<br>样本类型角度：ID3只能处理离散型变量，而C4.5和CART都可以处理连续型变量<br>应用角度：ID3和C4.5只能用于分类，而CART（classification and regression tree）还可以应用于回归（使用平方误差）<br>ID3对样本特征缺失值比较敏感，而C4.5和CART可以对缺失值进行不同方式的处理<br>ID3和C4.5可以在每个结点产生多叉分支，且每个特征在层级之间不会复用；CART只产生两个分支，每个特征可以被重复使用<br>ID3和C4.5通过剪枝来权衡树的准确性与泛化能力，而CART直接利用全部数据发现所有可能的树结构进行对比</p><p>剪枝：<br>预剪枝（pre-pruning）：在生成决策树的过程中提前停止树的生长 （局限：有欠拟合的风险）<br>   1.树的深度达到一定程度，停止树的生长；<br>   2.到达当前结点的样本数量小于某个阈值的时候，停止树的生长；<br>   3.计算每次分裂对测试集的准确度提升，当小于某个阈值时，停止<br>后剪枝  (post-pruning) : 让算法生成一颗完全生长的决策树，然后从最底层向上计算是否剪枝。剪枝过程将子树删除，用一个叶子结点替代，该结点的类别同样由多数投票的原则进行判断<br>相比于预剪枝，后剪枝通常可以得到泛化能力更强的决策树，但时间开销会更大</p><p>决策树生成的伪代码 (递归生成：base-如果数据集中所有样本分类一致，创建携带类标签的叶子结点；不然，寻找划分数据集的最好特征，根据其划分数据集，对于每个划分好的数据集，进行递归创建决策子树)</p></blockquote><h3 id="支持向量机-SVM"><a href="#支持向量机-SVM" class="headerlink" title="支持向量机 (SVM)"></a>支持向量机 (SVM)</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/84796233">参考</a><br>一句话总结：最大化分类间隔的线性分类器（不使用核函数时）<br>SVM有三宝，支撑（支持向量），间隔（分类间隔），核技巧（将低维非线性数据转换为高维线性数据的同时避免高维计算）；<br>SVM的分类结果仅依赖于支持向量；<br>超平面分离定理：对于两个不相交的凸集，存在一个超平面，将两个凸集分离</p></blockquote><h3 id="逻辑回归-LR"><a href="#逻辑回归-LR" class="headerlink" title="逻辑回归 (LR)"></a>逻辑回归 (LR)</h3><blockquote><p>一句话总结：假定数据服从逻辑斯蒂分布，利用MLE来求解参数<br>与线性回归的联系：如果把一个事件的几率（odds）定义为该事件发生的概率与不发生的概率的比值，$\frac{p}{1-p}$，那么逻辑回归可以看作是对于$y=1|x$这一事件的对数几率的线性回归<br>  Since $\text{Pr}[y=+1|x;\theta] = h(\theta^{\top}x)=\frac{1}{1+e^{-\theta^{\top}x}}, \quad \text{Pr}[y=-1|x;\theta] = 1 - \text{Pr}[y=+1|x;\theta] = \frac{1}{1+e^{\theta^{\top}x}}$. Thus,  $\text{Pr}[y|x;\theta] = \frac{1}{1+e^{-y\theta^{\top}x}}$<br>假设我们学习到了$\theta$，则当$\text{Pr}[y|x;\theta] = \frac{1}{1+e^{-y\theta^{\top}x}} \ge \frac{1}{2}$ 时，我们把数据划分为正类，由这个式子可以推出等价于 $\theta^{\top}x \ge 0$.<br>通过MLE，我们可以推导出Logistic损失函数：</p><script type="math/tex; mode=display">\frac{1}{n}\sum_{i=1}^{n}log(1+exp(-y_i\cdot\theta^{\top}x_i))</script><p>没有闭形式的解，但因为是凸函数，可以用基于梯度的优化方法求解，且解一定是quan ju zui you j</p></blockquote><p><strong>降维</strong></p><blockquote><p>降维：即用一个低维度的向量表示原始高维度的特征<br>常见的降维方法：PCA、LDA、等距映射、局部线性嵌入、拉普拉斯特征映射、局部保留投影</p></blockquote><h3 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析 (PCA)"></a>主成分分析 (PCA)</h3><blockquote><p>线性、非监督<br>PCA旨在找到数据的主成分，用之表征原始数据，达到降维的目的：找到一个投影方向，最大化投影方差（数据分布得更为分散）<br>Tips：样本投影后的方差就是对应协方差矩阵的特征值，我们要找的最大方差对应于协方差矩阵的最大特征值，最佳投影方向就是相应的特征向量（次佳投影方向位于最佳投影方向的正交空间中，即第二大特征值对应的特征向量）</p><ul><li>中心化样本数据</li><li>求样本协方差矩阵</li><li>对协方差矩阵进行特征值分解，并将其从大到小进行排序</li><li>取特征值前$d$ 大对应的特征向量$w_1, w_2, \dots, w_d$，通过以下映射将$n$ 维样本映射到$d$ 维：$x_i^{\prime} = [w_1^{\top}x_i, w_2^{\top}x_i, \dots, w_d^{\top}x_d]^{\top}$<br>定义降维后的信息占比：$\eta = \sqrt{\frac{\sum_{i=1}^d \lambda_i^2}{\sum_{i=1}^n \lambda_i^2}}$<br>注： 可以通过核映射对PCA进行扩展得到核主成分分析（KPCA），也可以通过流形映射的降维方法，比如等距映射，局部线性嵌入，拉普拉斯特征映射等对一些PCA效果不好的复杂数据集进行非线性降维操作<br>另一个角度：最小平方误差（待完善）</li></ul></blockquote><h3 id="线性判别分析（LDA）"><a href="#线性判别分析（LDA）" class="headerlink" title="线性判别分析（LDA）"></a>线性判别分析（LDA）</h3><blockquote><p>线性、有监督<br>LDA为分类服务，旨在找到一个投影方向，使得投影后的样本尽可能按照原始类别分开：最大化类间距离和最小化类内距离<br>类间距离：$|w^{\top}(\mu_1-\mu2)|_2^2$，将整个数据集的类内方差定义为各个类分别的方差之和：$D_1+D_2$<br>将目标函数定义为类间距离和类内距离的比值，从而需要最大化的目标： <script type="math/tex">max_w J(w) = \frac{\|w^{\top}(\mu_1-\mu2)\|_2^2}{D_1+D_2}</script><br>（后续推导待整理）<br>经过推导，我们最大化的目标对应了一个矩阵的特征值，于是LDA降维变成了一个求矩阵特征向量的问题<br> Notes：LDA对数据的分布做了很强的假设-每个类数据都是高斯分布，各个类的协方差相等；模型简单，表达能力有一定局限性，可以通过引入核函数扩展LDA方法以处理分布较为复杂的数据</p></blockquote><h3 id="K近邻-（KNN）"><a href="#K近邻-（KNN）" class="headerlink" title="K近邻 （KNN）"></a>K近邻 （KNN）</h3><blockquote><p>对于给定的训练数据集和新的样本，在训练数据集中找出与这个新的样本距离最近的k个样本点，然后多数投票原则决定该新样本点所属的分类<br>三要素：1. K值的选择（越小模型越复杂，交叉检验）；2.距离度量的选择（欧氏距离，马氏距离）； 3. 分类决策规则（多数表决）<br>KNN回归：在找到最近的k个实例之后，可以计算这k个实例的平均值作为预测值。或者还可以给这k个实例添加一个权重再求平均值，这个权重与度量距离成反比（越近权重越大）<br>KNN算法的优点：1.思想简单，理论成熟，既可以用来做分类也可以用来做回归；2.可用于非线性分类；3.训练时间复杂度为O(n)；3.准确度高，对数据没有假设，对outlier不敏感；<br>缺点：1.计算量大；2.样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；3.需要大量的内存；<br>KD树：（待整理）</p></blockquote><h3 id="朴素贝叶斯-（Naive-Bayes）"><a href="#朴素贝叶斯-（Naive-Bayes）" class="headerlink" title="朴素贝叶斯 （Naive Bayes）"></a>朴素贝叶斯 （Naive Bayes）</h3><blockquote><p>通过预测指定样本属于特定类别的概率$P(y_i|x)$来预测该样本的所属类别，即：$y = \text{argmax}_{y_i}P(y_i|x) (=\frac{P(x|y_i)P(y_)}{P(x)} $</p></blockquote><h3 id="K均值聚类-（K-Means）"><a href="#K均值聚类-（K-Means）" class="headerlink" title="K均值聚类 （K-Means）"></a>K均值聚类 （K-Means）</h3><blockquote><p>通过迭代方式寻找K个簇（cluster）的一种划分方案，使得聚类结果对应的损失函数最小<br>损失函数可以定义为各个样本距离所属簇中心点的误差平方和：$J(c,\mu)=\sum_{i=1}^{n}|x_i-\mu_{c_i}|^2$, 其中$x_i$ 代表第$i$ 个样本，$c_i$是$x_i$所属的簇，$\mu_{c_i}$代表簇对应的中心点，$n$ 为样本总数。</p></blockquote><p><strong>算法步骤</strong></p><ol><li>数据预处理，如归一化、离群点处理等</li><li>随机选取K个簇中心，记为$\mu_1^{(0)}, \mu_2^{(0)}, \dots, \mu_K^{(0)}$</li><li>定义损失函数：$J(c,\mu)=\sum_{i=1}^{n}|x_i-\mu_{c_i}|^2$</li><li>令$t=0, 1, 2, \dots$ 为迭代步数，重复下面过程直到J收敛：<br>4.1 对于每一个样本$x_i$，将其分配到距离最近的簇：$c_i^{(t)} \leftarrow \text{argmin}_k|x_i - \mu_k^{(t)}|^2$<br>4.2 对于每一个类簇，重新计算该类簇的中心：$\mu_k^{(t+1)} \leftarrow \text{argmin}_{\mu}\sum_{i:c_i^{(t)}=k}|x_i - \mu|^2$<br><strong>优缺点</strong><br>缺点：受初始值和离群点的影响每次的结果都不稳定，得到的解通常不是全局最优而是局部最优，无法很好解决数据簇分布差别比较大的情况，不太适用于离散分类等<br>优点：计算复杂度接近于线性 O(nKt)<br><strong>调优</strong></li><li>数据归一化和离群点处理</li><li>合理选取K值：如手肘法（经验方法）， Gap Statistic方法（Gap(K) = E(logD_k) - logD_k, 只需找到最大Gap statistic所对应的K即可)</li><li>采用核函数  核K均值算法（核聚类方法的一种）</li></ol><p><strong>改进的模型</strong><br>K-means++：（从改进初始值的角度）假设已经选取了n（0&lt;n&lt;K）个初始聚类中心，则在选取下一个聚类中心时，距离当前n个聚类中心越远的点会有更高的概率被选为下一个聚类中心<br>ISODATA算法：（当K值的大小不确定时）迭代自组织数据分析法 详见百面机器学习<br><strong>手写Kmeans代码</strong><br>待补充</p><h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><blockquote><p>将多个分类器的结果统一成一个最终的决策，其中每个单独的分类器称为基分类器<br>(1) 找到误差相互独立的基分类器<br>(2) 训练基分类器<br>(3) 合并基分类器的结果：Voting 和 stacking 两种。前者投票多数表决的方式，后者串行的方式</p></blockquote><h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><blockquote><p>相当于串联基分类器，层层叠加，对前一层分错的样本给予更高的权重，是一种迭代式的学习过程，就像复习错题并改正一样。对于模型的偏差有相应的改善<br>训练好一个弱分类器，计算弱分类器的残差，作为下一个分类器的输入（但使得各分类器之间是强相关的，缺乏独立性，不会对降低方差有用）<br>比如Adaboost<br>又比如梯度提升决策树（GBDT）：其核心是，每一棵树学的是之前所有树结论和的残差</p></blockquote><h3 id="Bagging-（Bootstrap-Aggregating）"><a href="#Bagging-（Bootstrap-Aggregating）" class="headerlink" title="Bagging （Bootstrap Aggregating）"></a>Bagging （Bootstrap Aggregating）</h3><blockquote><p>相当于并联基分类器，有一种D&amp;C的思想在里面，对训练样本多次采样，分别训练出多个不同的模型，然后做综合来减小模型的方差<br>比如随机森林<br>Bagging所采用的基分类器最好是本身对样本分布较为敏感的（即不稳定的分类器），这样bagging才有用武之地</p><p>最常用的基分类器是决策树，原因：</p><ol><li>更方便地把样本权重整合到训练过程中，不需要使用过采样的方法来调整样本权重</li><li>表达能力和泛化能力可以通过调节树的层数来做折中</li><li>不同子集样本集合生成的决策树基分类器随机性较大</li></ol><p>偏差：模型预测值和真实值差的期望    由偏差带来的误差通常在在训练误差上就能体现出来<br>方差：所有模型预测值的方差    由方差带来的误差通常体现在测试误差相对于训练误差的增量上</p></blockquote><h3 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h3><p>梯度提升决策树。Boosting的一种，体现了从错误中学习的理念，基于决策树预测的残差进行迭代的学习</p><blockquote><p>Gradient Boosting是Boosting的一大类算法，其基本思想是根据当前模型损失函数的负梯度信息来训练新加入的弱分类器，然后将训练好的弱分类器以累加的形式结合到现有模型中<br>在每一轮迭代中，首先计算出当前模型在所有样本上的负梯度，然后以该值为目标训练一个新的弱分类器进行拟合并计算出该弱分类器的权重，最终实现对模型的更新<br>GBDT中使用的决策树通常为CART</p><p>梯度提升 and 梯度下降<br>梯度下降：模型以参数化的形式表示，模型的更新等价于参数的更新<br>梯度提升：模型并不需要参数化表示，直接定义在函数空间中，从而大大扩展了可以使用的模型种类</p><p>GBDT优缺点<br>优点：1. 预测阶段计算速度快，树与树之前可以并行化计算；2. 分布稠密的数据集上，泛化能力和表达能力都很好；3. 采用决策树作为弱分类器使得其具有较好的解释性和鲁棒性，能自动发现特征间的高阶关系，不需要对数据进行特殊预处理<br>缺点：1. 在高维稀疏数据上表现不如SVM或者神经网络； 2. 处理文本分类特征问题上的优势不如处理数值特征时明显；3. 训练过程需要串行训练</p></blockquote><h3 id="XGboost"><a href="#XGboost" class="headerlink" title="XGboost"></a>XGboost</h3><p>实现了对GBDT算法的改进<br>原始的GBDT算法基于经验损失函数的负梯度来构造新的决策树，只是在决策树构建完成后再进行剪枝<br>而XGBoost在决策树构建阶段就加入了正则项<br>XGBoost有特定的准则来选取最优分裂</p><blockquote><p>与GBDT的联系和区别：</p><ol><li>GBDT是机器学习算法；XGBoost是该算法的工程实现</li><li>使用CART作为基分类器时，XGBoost显示地加入了正则项来控制模型的复杂度，有利于防止过拟合</li><li>GBDT在模型训练时只使用了损失函数的一阶导数信息，而XGBoost对损失函数进行二阶泰勒展开，可以同时使用一阶和二阶导数</li><li>传统的GBDT采用CART作为基分类器，而XGBoost支持多种类型的基分类器，比如线性的</li><li>传统的GBDT在每轮迭代时使用全部数据，而XGBoost则可以支持对数据采用</li><li>传统的GBDT没有设计对缺失值进行处理，而XGBoost能够自动学习出缺失值处理侧拉</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;模型评估&quot;&gt;&lt;a href=&quot;#模型评估&quot; class=&quot;headerlink&quot; title=&quot;模型评估&quot;&gt;&lt;/a&gt;模型评估&lt;/h2&gt;&lt;h3 id=&quot;分类准确率&quot;&gt;&lt;a href=&quot;#分类准确率&quot; class=&quot;headerli
      
    
    </summary>
    
    
    
      <category term="总结" scheme="https://yihang-li.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Python_for_Combinations</title>
    <link href="https://yihang-li.github.io/2021/03/13/Python_for_Combinations/"/>
    <id>https://yihang-li.github.io/2021/03/13/Python_for_Combinations/</id>
    <published>2021-03-13T03:04:34.257Z</published>
    <updated>2021-03-30T07:10:04.898Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-watch/">401.二进制手表</a>: 一道典型的回溯题，一般的思路是将num分解成h和m，分别表示hour中LED灯亮的数量和minute中LED灯亮的数量，同一个数量对应着不同的取值 i.e. h = 1 对应着 小时可以取到1， 2， 4， 8这四种取值，且都是合法的，而h=2对应着小时可以取到3， 5， 9，6，10，12 这6种取值，其中12超过了11是不合法的。</p><p>h的数量固定时，m= num - h 自然也就固定， 而我们要做的就是在固定h的数量时, 将所有合法的小时的对应取值H和分钟的对应取值MM组合起来成为 “H:MM”</p><p>沿着这个思路, 问题归结为两点：</p><blockquote><ul><li>其一， 给定h，如何算取[1， 2， 4， 8]的数量为h的合法组合（的和），自然也有m对应的</li><li>其二， 在第一点解决后，如何将给定h情况下，不同的小时对应的取值和分钟对应的取值组合起来</li></ul></blockquote><p>以上，难点在于 如何恰当地实现对组合数的求解</p><blockquote><p>给定一个长度为n的列表，求长度为h的不同组合 （注意，需要的是具体的组合，不是组合数）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span>(<span class="params">nums: <span class="built_in">list</span>, h: <span class="built_in">int</span></span>) -&gt; list[list]:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实回顾一下我们小学是怎么求组合的，这个问题也就不攻自破了：</p><blockquote><p>假定有一列数：a, b, c, d, e, …… 共n个</p><p>我们要求它的长度为k的组合，那么可以分两步：</p><ol><li>选择第一个数，从剩下的n-1个数里选择k-1个</li><li>第一个数不选，从剩下的n-1个数里选择k个数</li></ol></blockquote><p>有没有受到一点启发？我们减小了问题的规模😯</p><p>再考虑一下边界情况，我们就可以轻松实现求解所有的长度为h的组合啦</p><blockquote><ol><li>如果h &gt; n, 不满足组合的定义，用assert报错</li><li>如果列表的长度就是h，直接返回整个列表就好</li><li>如果h==0: 返回一个空列表</li><li>如果 h==1, 那直接枚举每一种可能</li></ol></blockquote><p>话不多说，上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combinations</span>(<span class="params">nums: <span class="built_in">list</span>, h: <span class="built_in">int</span></span>):</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    <span class="comment"># 如果h &gt; n, 不满足组合的定义，用assert报错</span></span><br><span class="line">    <span class="keyword">assert</span> h &lt;= n, <span class="string">&quot;h should be less than or eqaul to n!&quot;</span></span><br><span class="line">    <span class="comment"># 如果列表的长度就是h，直接返回整个列表就好</span></span><br><span class="line">    <span class="keyword">if</span> n == h: <span class="keyword">return</span> [nums]</span><br><span class="line">    <span class="comment"># 如果h==0: 返回一个空列表</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="number">0</span>: <span class="keyword">return</span> [[]]</span><br><span class="line"></span><br><span class="line">    res = []</span><br><span class="line">    <span class="comment"># 如果 h==1, 那直接枚举每一种可能</span></span><br><span class="line">    <span class="keyword">if</span> h == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res.append([num])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment"># 主要情形：1 &lt; h &lt; n</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># case 1: 选第一个，从剩下的n-1个里选h-1个</span></span><br><span class="line">    <span class="keyword">for</span> h_1_list <span class="keyword">in</span> combinations(nums[<span class="number">1</span>:], h-<span class="number">1</span>):</span><br><span class="line">        res.append([nums[<span class="number">0</span>]] + h_1_list)</span><br><span class="line">    <span class="comment"># case 2: 不选第一个，从剩下的n-1个里选h个</span></span><br><span class="line">    <span class="keyword">for</span> h_list <span class="keyword">in</span> combinations(nums[<span class="number">1</span>:], h):</span><br><span class="line">        res.append(h_list)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><a href="https://github.com/leetcode-pp/91alg-3/issues/45#issuecomment-797876551">我写的题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/binary-watch/&quot;&gt;401.二进制手表&lt;/a&gt;: 一道典型的回溯题，一般的思路是将num分解成h和m，分别表示hour中LED灯亮的数量和minute中LED灯亮的数量，同一个数量
      
    
    </summary>
    
    
    
      <category term="Python" scheme="https://yihang-li.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Sort Algorithm</title>
    <link href="https://yihang-li.github.io/2021/03/09/Sort_Algo/"/>
    <id>https://yihang-li.github.io/2021/03/09/Sort_Algo/</id>
    <published>2021-03-09T07:02:19.533Z</published>
    <updated>2021-03-30T07:30:36.912Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 Bubble Sort"></a>冒泡排序 Bubble Sort</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MySort</span>(<span class="params">self , arr </span>):</span></span><br><span class="line"><span class="comment">#         write code here</span></span><br><span class="line"><span class="comment">#         return sorted(arr)</span></span><br><span class="line">        <span class="comment">#冒泡排序 O(n**2) 超时</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; n-<span class="number">1</span>:</span><br><span class="line">            right = left + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right &lt; n:</span><br><span class="line">                <span class="keyword">if</span> arr[left] &gt; arr[right]:</span><br><span class="line">                    arr[left], arr[right] = arr[right], arr[left]</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序 Bucket Sort"></a>桶排序 Bucket Sort</h2><p>基本思路是：</p><ul><li>将待排序元素划分到不同的痛。先扫描一遍序列求出最大值 maxV 和最小值 minV ，设桶的个数为 k ，则把区间 [minV, maxV] 均匀划分成 k 个区间，每个区间就是一个桶。将序列中的元素分配到各自的桶。<br>对每个桶内的元素进行排序。可以选择任意一种排序算法, 将各个桶中的元素合并成一个大的有序序列。</li><li>假设数据是均匀分布的，则每个桶的元素平均个数为 n/k 。假设选择用快速排序对每个桶内的元素进行排序，那么每次排序的时间复杂度为 O(n/klog(n/k)) 。总的时间复杂度为 O(n)+O(k)O(n/klog(n/k)) = O(n+nlog(n/k)) = O(n+nlogn-nlogk 。当 k 接近于 n 时，桶排序的时间复杂度就可以金斯认为是 O(n) 的。即桶越多，时间效率就越高，而桶越多，空间就越大。</li></ul><p>原文链接：<a href="https://blog.csdn.net/qq_19446965/article/details/81517552">https://blog.csdn.net/qq_19446965/article/details/81517552</a></p><h2 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序 Counting Sort"></a>计数排序 Counting Sort</h2><ul><li>是一种O(n)的排序算法，其思路是开一个长度为 maxValue-minValue+1 的数组，然后分配。扫描一遍原始数组，以当前值- minValue 作为下标，将该下标的计数器增1。收集。扫描一遍计数器数组，按顺序把值收集起来。</li><li>举个例子， nums=[2, 1, 3, 1, 5] , 首先扫描一遍获取最小值和最大值， maxValue=5 , minValue=1 ，于是开一个长度为5的计数器数组 counter ，</li></ul><ol><li>分配。统计每个元素出现的频率，得到 counter=[2, 1, 1, 0, 1] ，例如 counter[0] 表示值 0+minValue=1 出现了2次。</li><li>收集。 counter[0]=2 表示 1 出现了两次，那就向原始数组写入两个1， counter[1]=1 表示 2 出现了1次，那就向原始数组写入一个2，依次类推，最终原始数组变为 [1,1,2,3,5] ，排序好了。</li></ol><p>计数排序本质上是一种特殊的桶排序，当桶的个数最大的时候，就是计数排序。</p><p>原文链接：<a href="https://blog.csdn.net/qq_19446965/article/details/81517552">https://blog.csdn.net/qq_19446965/article/details/81517552</a></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>待补充</p></blockquote><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MySort</span>(<span class="params">self , arr </span>):</span></span><br><span class="line"><span class="comment">#         write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_smallest</span>(<span class="params">arr</span>):</span></span><br><span class="line">            mini = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">            res = -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> index, a <span class="keyword">in</span> <span class="built_in">enumerate</span>(arr):</span><br><span class="line">                <span class="keyword">if</span> mini &gt; a:</span><br><span class="line">                    mini = a</span><br><span class="line">                    res = index</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            smallest = find_smallest(arr)</span><br><span class="line">            res.append(arr.pop(smallest))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 Quick Sort"></a>快速排序 Quick Sort</h2><blockquote><p>本质：分而治之 （Divide and Conquer, D&amp;C）</p></blockquote><ul><li>找基准值 （pivot element）</li><li>分区 （partitioning）</li></ul><p><strong>虚假的快排</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MySort</span>(<span class="params">self , arr </span>):</span></span><br><span class="line"><span class="comment">#       write code here</span></span><br><span class="line">        <span class="comment"># 快速排序</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pivot = arr[<span class="number">0</span>]</span><br><span class="line">            less = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &lt;= pivot]</span><br><span class="line">            greater = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:] <span class="keyword">if</span> i &gt; pivot]</span><br><span class="line">            <span class="keyword">return</span> self.MySort(less) + [pivot] + self.MySort(greater)</span><br></pre></td></tr></table></figure><p><strong>真实的快排</strong></p><p><strong>一. 挖坑填数分区法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition1</span>(<span class="params">arr, left, right</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;挖坑填数&quot;&quot;&quot;</span></span><br><span class="line">    pivot = arr[left]</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[right] &gt;= pivot: right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right: arr[left] = arr[right]</span><br><span class="line">        <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> arr[left] &lt;= pivot: left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right: arr[right] = arr[left]</span><br><span class="line">    arr[left] = pivot</span><br><span class="line">    <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure><p><strong>二. 双指针前后互换法</strong> 注：此方法老是写不对，需加强练习</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还需加强练习</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition2</span>(<span class="params">arr, left, right</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;双指针交换&quot;&quot;&quot;</span></span><br><span class="line">    pivot = arr[left]</span><br><span class="line">    index = left</span><br><span class="line">    <span class="keyword">while</span> left &lt; right:</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> arr[left] &lt;= pivot: left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> arr[right] &gt;= pivot: right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right: <span class="keyword">break</span></span><br><span class="line">        arr[left], arr[right] = arr[right], arr[left]</span><br><span class="line">    arr[index], arr[right] = arr[right], arr[index]</span><br><span class="line">    <span class="keyword">return</span> right</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition2_mid</span>(<span class="params">arr, left, right</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;双指针交换 + 三数取中优化&quot;&quot;&quot;</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> arr[left] &gt; arr[right]: arr[left], arr[right] = arr[right], arr[left]</span><br><span class="line">    <span class="keyword">if</span> arr[mid] &gt; arr[right]: arr[mid], arr[right] = arr[right], arr[mid]</span><br><span class="line">    <span class="keyword">if</span> arr[mid] &gt; arr[left]: arr[mid], arr[left] = arr[left], arr[mid]</span><br><span class="line">    pivot = arr[left]</span><br><span class="line">    index = left</span><br></pre></td></tr></table></figure><p><strong>三. 三路快排法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#优选</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition3</span>(<span class="params">arr, left, right</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;三路快排 + 三数取中&quot;&quot;&quot;</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> arr[left] &gt; arr[right]: arr[left], arr[right] = arr[right], arr[left]</span><br><span class="line">    <span class="keyword">if</span> arr[mid] &gt; arr[right]: arr[mid], arr[right] = arr[right], arr[mid]</span><br><span class="line">    <span class="keyword">if</span> arr[mid] &gt; arr[left]: arr[mid], arr[left] = arr[left], arr[mid]</span><br><span class="line">    pivot = arr[left]</span><br><span class="line">    i = left + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> arr[i] &gt; pivot:</span><br><span class="line">            arr[i], arr[right] = arr[right], arr[i]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] &lt; pivot:</span><br><span class="line">            arr[i], arr[left] = arr[left], arr[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> arr[i] == pivot:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> left, right</span><br></pre></td></tr></table></figure><p>主体：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span>(<span class="params">arr, left, right</span>):</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span></span><br><span class="line">    index = partition2(arr, left, right)</span><br><span class="line">    quick_sort(arr, left, index-<span class="number">1</span>)</span><br><span class="line">    quick_sort(arr, index+<span class="number">1</span>, right)</span><br></pre></td></tr></table></figure><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h2><blockquote><p>待补充！2020/03/09</p><p>快速查找的常量比归并查找的小</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MySort</span>(<span class="params">self , arr </span>):</span></span><br><span class="line"><span class="comment">#       write code here</span></span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        m = (<span class="number">0</span> + n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="comment"># 分</span></span><br><span class="line">        left_part = self.MySort(arr[:m+<span class="number">1</span>])</span><br><span class="line">        right_part = self.MySort(arr[m+<span class="number">1</span>:])</span><br><span class="line">        <span class="comment"># 治</span></span><br><span class="line">        merge_list = []</span><br><span class="line">        <span class="keyword">while</span> left_part <span class="keyword">and</span> right_part:</span><br><span class="line">            <span class="keyword">if</span> left_part[<span class="number">0</span>] &lt;=  right_part[<span class="number">0</span>]:</span><br><span class="line">                merge_list.append(left_part.pop(<span class="number">0</span>))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                merge_list.append(right_part.pop(<span class="number">0</span>))</span><br><span class="line">        rest_ = left_part <span class="keyword">if</span> left_part <span class="keyword">else</span> right_part</span><br><span class="line">        merge_list.extend(rest_)</span><br><span class="line">        <span class="keyword">return</span> merge_list</span><br></pre></td></tr></table></figure><blockquote><p>上述写法，切片和pop耗时太多，改为下面写法，不切片，不pop</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MySort</span>(<span class="params">self , arr </span>):</span></span><br><span class="line"><span class="comment">#       write code here</span></span><br><span class="line">        <span class="comment"># 修改， 不使用切片和pop</span></span><br><span class="line">        <span class="comment"># 先定义 治</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">arr, start, mid, end</span>):</span></span><br><span class="line">            <span class="comment"># i for left_part; j for right_part</span></span><br><span class="line">            i, j = start, mid + <span class="number">1</span></span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= end:</span><br><span class="line">                <span class="keyword">if</span> arr[i] &lt;= arr[j]:</span><br><span class="line">                    tmp.append(arr[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp.append(arr[j])</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= mid:</span><br><span class="line">                tmp.append(arr[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">                tmp.append(arr[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)):</span><br><span class="line">                arr[start + i] = tmp[i]</span><br><span class="line">        <span class="comment"># 再定义 分</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span>(<span class="params">arr, start, end</span>):</span></span><br><span class="line"><span class="comment">#             print(start, end)</span></span><br><span class="line">            <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span></span><br><span class="line">            mid = (start + end) &gt;&gt; <span class="number">1</span></span><br><span class="line">            merge_sort(arr, start, mid)</span><br><span class="line">            merge_sort(arr, mid+<span class="number">1</span>, end)</span><br><span class="line">            merge(arr, start, mid, end)</span><br><span class="line">        merge_sort(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;冒泡排序-Bubble-Sort&quot;&gt;&lt;a href=&quot;#冒泡排序-Bubble-Sort&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序 Bubble Sort&quot;&gt;&lt;/a&gt;冒泡排序 Bubble Sort&lt;/h2
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://yihang-li.github.io/categories/Notes/"/>
    
    
      <category term="Algorithm" scheme="https://yihang-li.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>卷积神经网络 （CNN）</title>
    <link href="https://yihang-li.github.io/2021/03/01/CNN/"/>
    <id>https://yihang-li.github.io/2021/03/01/CNN/</id>
    <published>2021-03-01T08:34:06.370Z</published>
    <updated>2021-03-30T07:18:37.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-CNN？"><a href="#What-is-CNN？" class="headerlink" title="What is CNN？"></a>What is CNN？</h2><p>前馈神经网络的一种，主要由卷积层构成，具有<code>局部连接（稀疏交互）</code>和<code>权值共享（参数共享）</code>等特性，主要用于图像识别领域</p><a id="more"></a><h2 id="Why-CNN？"><a href="#Why-CNN？" class="headerlink" title="Why CNN？"></a>Why CNN？</h2><h3 id="Problems-of-fully-connected-neural-networks"><a href="#Problems-of-fully-connected-neural-networks" class="headerlink" title="Problems of fully connected neural networks"></a>Problems of fully connected neural networks</h3><ul><li>输出层的每个结点会与输入层的每个结点相连</li><li>参数数量随着输入图片尺寸的增大而大大增加</li></ul><h3 id="Why-CNN"><a href="#Why-CNN" class="headerlink" title="Why CNN?"></a>Why CNN?</h3><ul><li>通过图片的一些pattern来识别整张图片，而识别这些pattern并不需要看整张图片</li><li>相同的pattern可能会出现在图片的不同位置</li><li>对图片进行降采样（池化）不会改变图片的特征，带来的好处是需要的参数量大大减小</li></ul><h2 id="Some-Basic-Ideas"><a href="#Some-Basic-Ideas" class="headerlink" title="Some Basic Ideas"></a>Some Basic Ideas</h2><p><code>卷积运算（Convolutional Operator）</code></p><script type="math/tex; mode=display">s(t) = (x*w)(t) = \int x(a)w*(t-a)da=\sum_{a=-\infty}^{\infty}x(a)w(t-a)</script><p>第二个等号为连续情形；第三个等号为离散情形<br>$x$称为输入，$w$称为核函数，也叫filter，输出有时称作特征映射(feature map)</p><p>注：</p><ul><li>卷积是可交换的，这是因为将核相对于输入进行翻转(flip)；</li><li>通常使用的互相关函数(cross-crorrelation)，和卷积运算几乎一样但是没有对核进行翻转</li><li>实际中，对应项相乘相加</li><li>在深度学习中核数组都是学习出来的：卷积层无论使用互相关运算或卷积运算都不影响模型预测时的输出</li></ul><p><code>通道（channel）</code> 例如对RGB图片来说，channel的数量是3（分别对应R、G、B），而对于单色图片来说channel的数量是1. 总体而言，channel可以分为下述三种：</p><ul><li>最初输入图片样本的in_channel，取决于图片类型</li><li>卷积操作完成后输出的out_channel, 取决于卷积核的数量（此时的out_channel也会作为下一次卷积时卷积核的in_channel）</li><li>卷积核中的in_channel. 即上一次卷积的out_channel, 或者当第一次卷积时，为对应图片样本的channel</li></ul><blockquote><p>具体来说，卷积层是通过特定数目的卷积核（filter）对输入的多通道（channel）特征图进行扫描和运算，从而得到多个拥有更高层语义信息的输出特征图（通道数目等于卷积核个数）</p></blockquote><p><code>感受野（Receptive Field)</code> 对于<em>某层输出特征图</em>上的某个点，在卷积神经网络的<em>原始输入数据</em>上能影响到这个点的取值的区域</p><blockquote><p>可以通过更深的卷积神经网络使特征图中单个元素的感受野变得更加广阔，从而捕捉输入上更大尺寸的特征</p></blockquote><p><code>步幅（Stride）</code>卷积核窗口每次滑动的行数和列数（No-Stride: Stride = 1）</p><p><code>填充（Padding）</code>是指在输入高和宽（二维情形）的两侧填充元素（通常是0元素，zero-padding）</p><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><h3 id="Sparse-Interactions"><a href="#Sparse-Interactions" class="headerlink" title="Sparse Interactions"></a>Sparse Interactions</h3><p><code>稀疏交互</code> 卷积核尺度远小于输入的维度，每个输出神经元仅与前一层特定区域内的神经元存在连接权重（即产生交互）<br>注：让网络变得简单，可以缓解过拟合；物理意义：先学习局部特征，再把局部特征组合起来形成更复杂和抽象的特征</p><h3 id="Parameter-Sharing"><a href="#Parameter-Sharing" class="headerlink" title="Parameter Sharing"></a>Parameter Sharing</h3><p><code>参数共享</code> 在同一个模型的不同模块中使用相同的参数（即卷积核），卷积运算的固有属性<br>注：大大降低了模型的存储需求；物理意义：参数共享使得卷积层具有平移等变性（equivariance）</p><h2 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h2><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a><a href="https://nealjean.com/ml/neural-network-normalization/">Batch Normalization</a></h3><p><code>Covariate Shift</code>: 模型的训练集和测试集的分布不一致，或者模型在训练过程中输入数据的分布发生变化</p><p>对于一个复杂的机器学习系统，在训练过程中一般会要求系统里各个子模块的输入分布是稳定的，如果不满足，则称为内部协变量偏移（Internal covariant shift），网络越深，这种现象越明显</p><p>The goal of BN is to reduce <code>internal covariate shift</code> by normalizing each mini-batch of data using the mini-batch mean and variance.</p><p>采用批量归一化后，深度神经网络的训练过程更加稳定、对初始值不再那么敏感、可以采用较大的学习率来加速收敛</p><p>BN可以看作是带参数的标准化：$y^{(k)} = \gamma^{(k)}\frac{x^{(k)}-\mu^{(k)}}{\sqrt{(\sigma^{(k)})^2+\epsilon}}+\beta^{(k)}$. 其中，$x^{(k)}, y^{(k)}$分别是原始输入数据和BN后的输出数据，$\mu^{(k)}, \sigma^{(k)}$分别是输入数据的均值和标准差（在mini-batch上），$\beta^{(k)}, \gamma^{(k)}$分别是可学习的平移参数和缩放参数，上标$k$表示数据的第$k$维（BN在数据各个维度上是独立进行的），$\epsilon$是为防止分母为0的一个小量</p><p>BN 在网络中的位置有争议</p><h2 id="Pooling"><a href="#Pooling" class="headerlink" title="Pooling"></a>Pooling</h2><p><code>池化</code> 本质是降采样，能显著降低参数量（降维），还能保持对平移、伸缩、旋转操作的不变性。<br>注：池化主要是从降低计算复杂度的角度来考虑，但是当计算资源充沛的时候，有些任务不进行池化会有更好的效果，而且对另一些任务来说，是不能进行池化操作的，i.e. 下围棋，Alpha Go（详见李宏毅）</p><p>常用池化：</p><ol><li>Mean Pooling（对池化窗口求均值）: 能够抑制由于领域大小受限造成的估计值方差增大的现象，特点是对背景的保留效果更好</li><li>max pooling（取池化窗口内的最大值）：能够抑制网络参数误差造成估计均值偏移的现象，特点是更好地提取纹理信息</li></ol><h2 id="Computation"><a href="#Computation" class="headerlink" title="Computation"></a>Computation</h2><p>假设一个卷积层输入特征图的尺寸为$l_w^{(i)}\times l_h^{(i)}$，卷积核大小为$k_w \times k_h$，步长为$s_w \times s_h$，则输出特征图的尺寸$l_w^{(o)}\times l_h^{(o)}$ 如何计算？</p><p>Note：假设在卷积核的滑动过程中，我们对输入特征图的左右两侧分别进行了$p_w$列填充，上下两侧分别进行了$p_h$行填充，填充后的特征图尺寸为$(l_w^{(i)}+2p_w)\times (l_h^{(i)}+2p_h)$，则输出特征图的尺寸为：</p><script type="math/tex; mode=display">l_e^{(o)} = \left\lfloor\frac{l_e^{(i)} + 2p_e - k_e}{s_e}\right\rfloor + 1, e \in \{w, h\}</script><p>如果输入特征图的通道数为$c^{(i)}$，输出特征图的通道数为$c^{(o)}$，在不考虑偏置项（bias）的情况下，卷积层的参数量和计算量是多少？</p><p>参数量：卷积层的参数量，主要取决于每个卷积核的参数量以及卷积核的个数。这里，每个卷积核含有$c^{(i)}k_wk_h$个参数，而卷积核的个数即输出特征图的通道个数$c^{(o)}$，因此参数总量为：</p><script type="math/tex; mode=display">c^{(i)}c^{(o)}k_wk_h</script><p>计算量：卷积层的计算量，由卷积核在每个滑动窗口内的计算量以及整体的滑动次数决定。在每个滑动窗口内，卷积操作的计算量大约为$c^{(i)}k_wk_h$，而卷积核的滑动次数即输出特征图的数据个数，也就是$c^{(o)}l_w^{(o)}l_h^{(o)}$，因此整体的计算量为：</p><script type="math/tex; mode=display">c^{(i)}c^{(o)}l_w^{(o)}l_h^{(o)}k_wk_h</script><h2 id="Typical-architecture-of-CNN"><a href="#Typical-architecture-of-CNN" class="headerlink" title="Typical architecture of CNN"></a>Typical architecture of CNN</h2><p>Convo + Normal + Pooling</p><h2 id="BP-on-CNN"><a href="#BP-on-CNN" class="headerlink" title="BP on CNN"></a>BP on CNN</h2><p><a href="https://medium.com/@pavisj/convolutions-and-backpropagations-46026a8f5d2c">或许看看这个</a>：The backward pass during Backpropagation also uses convolutions!</p><p>【参考】</p><ol><li><a href="https://www.youtube.com/watch?v=OP5HcXJg2Aw">李宏毅</a></li><li><a href="https://d2l.ai/chapter_convolutional-neural-networks/conv-layer.html">D2L</a></li><li>花书</li><li>百面机器学习</li><li>百面深度学习</li><li>课件</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;What-is-CNN？&quot;&gt;&lt;a href=&quot;#What-is-CNN？&quot; class=&quot;headerlink&quot; title=&quot;What is CNN？&quot;&gt;&lt;/a&gt;What is CNN？&lt;/h2&gt;&lt;p&gt;前馈神经网络的一种，主要由卷积层构成，具有&lt;code&gt;局部连接（稀疏交互）&lt;/code&gt;和&lt;code&gt;权值共享（参数共享）&lt;/code&gt;等特性，主要用于图像识别领域&lt;/p&gt;
    
    </summary>
    
    
      <category term="Notes" scheme="https://yihang-li.github.io/categories/Notes/"/>
    
    
      <category term="Deep Learning" scheme="https://yihang-li.github.io/tags/Deep-Learning/"/>
    
  </entry>
  
  <entry>
    <title>前缀和</title>
    <link href="https://yihang-li.github.io/2021/02/07/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    <id>https://yihang-li.github.io/2021/02/07/%E5%89%8D%E7%BC%80%E5%92%8C/</id>
    <published>2021-02-07T15:44:42.926Z</published>
    <updated>2021-03-30T07:31:15.191Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://lucifer.ren/blog/2020/09/27/atMostK/">路西法，前缀和</a>：不明所以</p><p><a href="https://labuladong.github.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7.html">labuladong</a>👀️</p><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><blockquote><p><a href="https://lucifer.ren/blog/2021/02/20/2d-pre/">Lucifer</a> 二维的写得比一维的清晰</p></blockquote><ul><li>简单二维前缀和的求解 基于 <code>容斥原理</code></li></ul><a id="more"></a><h4 id="二维前缀和转化为一维前缀和-（遍历矩阵所有的以第一行为上端的区块和）"><a href="#二维前缀和转化为一维前缀和-（遍历矩阵所有的以第一行为上端的区块和）" class="headerlink" title="二维前缀和转化为一维前缀和 （遍历矩阵所有的以第一行为上端的区块和）"></a>二维前缀和转化为一维前缀和 （遍历矩阵所有的<code>以第一行为上端</code>的区块和）</h4><blockquote><p>先不考虑行之间的关联，而是预先计算出每一行的前缀和。对于计算每一行的前缀和就是<strong>一维前缀和</strong>啦。接下来通过<strong>固定两个列的端点</strong>的方式计算每一行的区域和。代码上，我们可以通过三层循环来实现， 其中两层循环用来固定列端点，另一层用于枚举所有行。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预先构建行的前缀和</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        row[i + <span class="number">1</span>] += row[i]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 固定列的两个端点，即枚举所有列的组合</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">        pres = [<span class="number">0</span>]</span><br><span class="line">        pre = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 枚举所有行</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="comment"># matrix[k] 其实已经是上一步预处理的每一行的前缀和了。因此 matrix[k][j] - (matrix[k][i - 1] 就是每一行 [i, j] 的区域和。</span></span><br><span class="line">            pre += matrix[k][j] - (matrix[k][i - <span class="number">1</span>] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">            pres.append(pre)</span><br></pre></td></tr></table></figure><blockquote><p><code>上面代码做的事情形象来看，就是先在水平方向计算前缀和，然后在竖直方向计算前缀和，而不是同时在两个方向计算。</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://lucifer.ren/blog/2020/09/27/atMostK/&quot;&gt;路西法，前缀和&lt;/a&gt;：不明所以&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://labuladong.github.io/algo/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E7%B3%BB%E5%88%97/%E5%89%8D%E7%BC%80%E5%92%8C%E6%8A%80%E5%B7%A7.html&quot;&gt;labuladong&lt;/a&gt;👀️&lt;/p&gt;
&lt;h3 id=&quot;二维前缀和&quot;&gt;&lt;a href=&quot;#二维前缀和&quot; class=&quot;headerlink&quot; title=&quot;二维前缀和&quot;&gt;&lt;/a&gt;二维前缀和&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://lucifer.ren/blog/2021/02/20/2d-pre/&quot;&gt;Lucifer&lt;/a&gt; 二维的写得比一维的清晰&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;简单二维前缀和的求解 基于 &lt;code&gt;容斥原理&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://yihang-li.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://yihang-li.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Union Find</title>
    <link href="https://yihang-li.github.io/2021/01/24/Leetcode_Union_Find/"/>
    <id>https://yihang-li.github.io/2021/01/24/Leetcode_Union_Find/</id>
    <published>2021-01-23T21:15:32.000Z</published>
    <updated>2021-03-30T07:09:15.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="并查集算法"><a href="#并查集算法" class="headerlink" title="并查集算法"></a>并查集算法</h2><ul><li>[X] 动手使用python实现<code>并查集</code>4个版本🚀️</li><li>[ ] 应用刷题！🎉️：刷完<a href="https://leetcode-cn.com/tag/union-find/">并查集tag</a>再勾（7/39）</li></ul><a id="more"></a><h3 id="动手实现"><a href="#动手实现" class="headerlink" title="动手实现"></a>动手实现</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union_Find</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Initialize a list of length n: n nodes as index and root as value,</span></span><br><span class="line"><span class="string">count: the number of disjoint set&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>)-&gt;bool:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;decide if p and q are in the same disjoint set &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;connect node p and node q &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p:<span class="built_in">int</span></span>)-&gt;int:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;find the root of p&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="First-Version-quick-find"><a href="#First-Version-quick-find" class="headerlink" title="First Version: quick-find"></a>First Version: quick-find</h4><blockquote><p>uf 初始化为index：结点， value： 结点自身</p><p>if uf[p] == uf[q]: p, q 在同一个连通分量</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># quick-find</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union_Find</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Initialize a list: Nodes as index and root as value,</span></span><br><span class="line"><span class="string">count: the number of disjoint set, &quot;&quot;&quot;</span></span><br><span class="line">self.<span class="built_in">len</span> = n</span><br><span class="line">self.uf = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">len</span>)]</span><br><span class="line">self.count = n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p:<span class="built_in">int</span></span>)-&gt;int:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;find the root of p&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> self.uf[p]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>)-&gt;bool:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;decide if p and q are in the same disjoint set &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> self.find(p) == self.find(q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;connect node p and node q &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> self.is_connected(p, q): <span class="keyword">return</span></span><br><span class="line">p_root, q_root = self.find(p), self.find(q)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">len</span>):</span><br><span class="line"><span class="keyword">if</span> self.find(i) == p_root:</span><br><span class="line">self.uf[i] = q_root</span><br><span class="line">self.count -= <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>算法分析：find() 操作速度很快，但是对于每一对需要连接的输入，union() 都需要扫描整个 uf 数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quick-find 算法一般不能处理大型问题</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; quick-find ～</span><br></pre></td></tr></table></figure><p>$O(n^2)$</p></blockquote><h4 id="Second-Version-quick-union"><a href="#Second-Version-quick-union" class="headerlink" title="Second Version: quick-union"></a>Second Version: quick-union</h4><blockquote><p>uf 用父链接的形式表示了一片森林（每个父链接对应一棵树，既一个连通分量）</p><p>数组uf 中元素都是同一个连通分量中另一个结点的名称，当为它自身时表示其为该连通分量中的根结点</p><p>由结点p, q 的链接分别找到它们的根结点， 然后将一个根结点链接到另一个即可连通两个连通分量</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># quick-union</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union_Find</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Initialize a list: Nodes as index and root as value,</span></span><br><span class="line"><span class="string">count: the number of disjoint set, &quot;&quot;&quot;</span></span><br><span class="line">self.<span class="built_in">len</span> = n</span><br><span class="line">self.uf = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">len</span>)]</span><br><span class="line">self.count = n</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p:<span class="built_in">int</span></span>)-&gt;int:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;find the root of p&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> self.uf[p] != p: p = self.uf[p]</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>)-&gt;bool:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;decide if p and q are in the same disjoint set &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> self.find(p) == self.find(q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;connect node p and node q &quot;&quot;&quot;</span></span><br><span class="line">p_root, q_root = self.find(p), self.find(q)</span><br><span class="line"><span class="keyword">if</span> p_root == q_root: <span class="keyword">return</span></span><br><span class="line">self.uf[p_root] = q_root</span><br><span class="line">self.count -= <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>算法分析： 最好情况～$O(n)$, 最差情况~$O(n^2)$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quick-find 的改进，解决了其最主要的问题：使得union的操作变成了线性</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不能保证所有情况下它都比quick-find快</span><br></pre></td></tr></table></figure><h4 id="Third-Version-weighted-quick-union"><a href="#Third-Version-weighted-quick-union" class="headerlink" title="Third Version: weighted-quick-union"></a>Third Version: weighted-quick-union</h4><p>记录每一棵树🌲的大小（也就是我们的weight），在union合并操作的时候总是将小树链接到大树上</p><p>空间换时间</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># weighted-quick-union</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union_Find</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Initialize a list: Nodes as index and root as value,</span></span><br><span class="line"><span class="string">count: the number of disjoint set, &quot;&quot;&quot;</span></span><br><span class="line">self.<span class="built_in">len</span> = n</span><br><span class="line">self.uf = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">len</span>)]</span><br><span class="line">self.count = n</span><br><span class="line">self.size = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">len</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p:<span class="built_in">int</span></span>)-&gt;int:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;find the root of p&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> self.uf[p] != p: p = self.uf[p]</span><br><span class="line"><span class="keyword">return</span> p</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>)-&gt;bool:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;decide if p and q are in the same disjoint set &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> self.find(p) == self.find(q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;connect node p and node q &quot;&quot;&quot;</span></span><br><span class="line">p_root, q_root = self.find(p), self.find(q)</span><br><span class="line"><span class="keyword">if</span> p_root == q_root: <span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> self.size[p_root] &lt; self.size[q_root]:</span><br><span class="line">self.uf[p_root] = q_root</span><br><span class="line">self.size[q_root] += self.size[p_root]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">self.uf[q_root] = p_root</span><br><span class="line">self.size[p_root] += self.size[q_root]</span><br><span class="line">self.count -= <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>算法分析： weighted-quick-union ~ $O(log(n))$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 这三种算法中唯一能用于解决大型实际问题的算法🎉</span><br></pre></td></tr></table></figure><h4 id="Optimal-Version-weighted-quick-union-with-path-compression"><a href="#Optimal-Version-weighted-quick-union-with-path-compression" class="headerlink" title="Optimal Version: weighted-quick-union with path compression"></a>Optimal Version: weighted-quick-union with path compression</h4><p>希望每个结点都直接链接到它的根结点上，但又不想像quick-find那样在union中通过for循环修改所有结点链接——&gt;路径压缩</p><p>在find结点的同时将它们链接到根结点：为find添加一个循环将在路径上遇到的所有节点都直接链接到根结点</p><p>得到几乎完全扁平化的树🌲</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># weighted-quick-union</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union_Find</span>():</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;Initialize a list: Nodes as index and root as value,</span></span><br><span class="line"><span class="string">count: the number of disjoint set, &quot;&quot;&quot;</span></span><br><span class="line">self.<span class="built_in">len</span> = n</span><br><span class="line">self.uf = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">len</span>)]</span><br><span class="line">self.count = n</span><br><span class="line">self.size = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">len</span>)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span>(<span class="params">self, p:<span class="built_in">int</span></span>)-&gt;int:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;find the root of p&quot;&quot;&quot;</span></span><br><span class="line">res = p</span><br><span class="line"><span class="keyword">while</span> self.uf[res] != res: res = self.uf[res]</span><br><span class="line"><span class="keyword">while</span> self.uf[p] != p: p, self.uf[p] = self.uf[p], res</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_connected</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>)-&gt;bool:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;decide if p and q are in the same disjoint set &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">return</span> self.find(p) == self.find(q)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span>(<span class="params">self, p: <span class="built_in">int</span>, q: <span class="built_in">int</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;connect node p and node q &quot;&quot;&quot;</span></span><br><span class="line">p_root, q_root = self.find(p), self.find(q)</span><br><span class="line"><span class="keyword">if</span> p_root == q_root: <span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> self.size[p_root] &lt; self.size[q_root]:</span><br><span class="line">self.uf[p_root] = q_root</span><br><span class="line">self.size[q_root] += self.size[p_root]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">self.uf[q_root] = p_root</span><br><span class="line">self.size[p_root] += self.size[q_root]</span><br><span class="line">self.count -= <span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>算法分析：weighted-quick-union with path compression 是这四者中最优的算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但并非所有操作都能在常数时间内完成</span><br></pre></td></tr></table></figure><h3 id="应用刷题"><a href="#应用刷题" class="headerlink" title="应用刷题"></a>应用刷题</h3></blockquote><ul><li>[X] <a href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">1319</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeConnected</span>(<span class="params">self, n: <span class="built_in">int</span>, connections: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(connections) &lt; n - <span class="number">1</span>: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        uf = Union_Find(n)</span><br><span class="line">        edges = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> connections:</span><br><span class="line">            <span class="keyword">if</span> uf.is_connected(i, j):</span><br><span class="line">                edges += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            uf.union(i, j)</span><br><span class="line">        <span class="keyword">if</span> edges &gt;= uf.count - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> uf.count - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/number-of-provinces/">547</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span>(<span class="params">self, isConnected: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(isConnected)</span><br><span class="line">        uf = Union_Find(n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> isConnected[i][j]:</span><br><span class="line">                    uf.union(i, j)</span><br><span class="line">        <span class="keyword">return</span> uf.count</span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        uf = Union_Find(n*n)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">height_t</span>(<span class="params">t</span>):</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> grid[i][j] == t:</span><br><span class="line">                        <span class="keyword">return</span> i, j</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n*n):</span><br><span class="line">            i, j = height_t(t)</span><br><span class="line">            <span class="keyword">if</span> i-<span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[i-<span class="number">1</span>][j] &lt;= t:</span><br><span class="line">                uf.union(grid[i][j], grid[i-<span class="number">1</span>][j])</span><br><span class="line">            <span class="keyword">if</span> i+<span class="number">1</span> &lt; n <span class="keyword">and</span> grid[i+<span class="number">1</span>][j] &lt;= t:</span><br><span class="line">                uf.union(grid[i][j], grid[i+<span class="number">1</span>][j])</span><br><span class="line">            <span class="keyword">if</span> j-<span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[i][j-<span class="number">1</span>] &lt;= t:</span><br><span class="line">                uf.union(grid[i][j], grid[i][j-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span> &lt; n <span class="keyword">and</span> grid[i][j+<span class="number">1</span>] &lt;= t:</span><br><span class="line">                uf.union(grid[i][j], grid[i][j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> uf.is_connected(grid[<span class="number">0</span>][<span class="number">0</span>], grid[n-<span class="number">1</span>][n-<span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> t</span><br><span class="line">        <span class="keyword">return</span> t</span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/satisfiability-of-equality-equations/">990</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">equationsPossible</span>(<span class="params">self, equations: List[<span class="built_in">str</span>]</span>) -&gt; bool:</span></span><br><span class="line"></span><br><span class="line">        alpha_set = <span class="built_in">set</span>()</span><br><span class="line">        alpha_dict = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> equation <span class="keyword">in</span> equations:</span><br><span class="line">            alpha_set.add(equation[<span class="number">0</span>])</span><br><span class="line">            alpha_set.add(equation[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">        n = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> alpha_set:</span><br><span class="line">            alpha_dict[i] = n</span><br><span class="line">            n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        uf = Union_Find(n)</span><br><span class="line"></span><br><span class="line">        equations.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> equation <span class="keyword">in</span> equations:</span><br><span class="line">            <span class="keyword">if</span> equation[<span class="number">1</span>] == <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                uf.union(alpha_dict[equation[<span class="number">0</span>]], alpha_dict[equation[<span class="number">3</span>]])</span><br><span class="line">            <span class="keyword">elif</span> uf.is_connected(alpha_dict[equation[<span class="number">0</span>]], alpha_dict[equation[<span class="number">3</span>]]):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/">674</a> &gt; 这题能用并查集是我没想到的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findLengthOfLCIS</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        uf = Union_Find(n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &lt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                uf.union(i, i+<span class="number">1</span>) <span class="comment">##</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(uf.size)</span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/">959</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">regionsBySlashes</span>(<span class="params">self, grid: List[<span class="built_in">str</span>]</span>) -&gt; int:</span></span><br><span class="line">        N = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = N**<span class="number">2</span> * <span class="number">4</span></span><br><span class="line">        uf = Union_Find(n)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            ith_row = grid[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">                index = <span class="number">4</span> * (i * N + j) <span class="comment">### index</span></span><br><span class="line">                c = ith_row[j]</span><br><span class="line">                <span class="comment">#单元格内合并</span></span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    uf.union(index, index+<span class="number">1</span>)</span><br><span class="line">                    uf.union(index+<span class="number">1</span>, index+<span class="number">2</span>)</span><br><span class="line">                    uf.union(index+<span class="number">2</span>, index+<span class="number">3</span>)</span><br><span class="line">                <span class="keyword">elif</span> c == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    uf.union(index, index+<span class="number">3</span>)</span><br><span class="line">                    uf.union(index+<span class="number">1</span>, index+<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    uf.union(index, index+<span class="number">1</span>)</span><br><span class="line">                    uf.union(index+<span class="number">2</span>, index+<span class="number">3</span>)</span><br><span class="line">                <span class="comment"># #单元格间合并</span></span><br><span class="line">                <span class="comment"># if j &lt; N - 1: #right-bound</span></span><br><span class="line">                <span class="comment">#     uf.union(index+1, index+7)</span></span><br><span class="line">                <span class="comment"># if i &lt; N - 1: #lower-bound</span></span><br><span class="line">                <span class="comment">#     uf.union(index+2, 4*((i+1)*N)+j)</span></span><br><span class="line">                <span class="comment">#换一种单元格间合并试试</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>: uf.union(index, <span class="number">4</span>*((i-<span class="number">1</span>)*N + j)+<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>: uf.union(index+<span class="number">3</span>, <span class="number">4</span>*(i*N+j-<span class="number">1</span>)+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> uf.count</span><br></pre></td></tr></table></figure><blockquote><p>为什么向右向下合并不对，向上向左合并就对了呢？</p></blockquote><ul><li>[X] <a href="https://leetcode-cn.com/problems/number-of-islands/">200</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        row, col = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        count_1, count_0 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;0&quot;</span>: count_0 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: count_1 += <span class="number">1</span></span><br><span class="line">        uf = Union_Find(row*col)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                index = i*col+j</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    <span class="comment">#上</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> grid[i-<span class="number">1</span>][j] == <span class="string">&quot;1&quot;</span>: uf.union(index, (i-<span class="number">1</span>)*col+j)</span><br><span class="line">                    <span class="comment">#左</span></span><br><span class="line">                    <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> grid[i][j-<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>: uf.union(index, index-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> uf.count - count_0</span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/redundant-connection/">684</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRedundantConnection</span>(<span class="params">self, edges: List[List[<span class="built_in">int</span>]]</span>) -&gt; List[int]:</span></span><br><span class="line">        n = <span class="built_in">len</span>(edges)</span><br><span class="line">        uf = Union_Find(n)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> uf.is_connected(i-<span class="number">1</span>, j-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> [i, j]</span><br><span class="line">            uf.union(i-<span class="number">1</span>, j-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/">1579</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxNumEdgesToRemove</span>(<span class="params">self, n: <span class="built_in">int</span>, edges: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        uf_Alice = Union_Find(n)</span><br><span class="line">        uf_Bob = Union_Find(n)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        edge1, edge2, edge3 = [], [], []</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> edge[<span class="number">0</span>] == <span class="number">1</span>: edge1.append(edge[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">elif</span> edge[<span class="number">0</span>] == <span class="number">2</span>: edge2.append(edge[<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">else</span>: edge3.append(edge[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="comment">#先连接公共边</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> edge3:</span><br><span class="line">            <span class="keyword">if</span> uf_Alice.is_connected(i-<span class="number">1</span>, j-<span class="number">1</span>):</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uf_Alice.union(i-<span class="number">1</span>, j-<span class="number">1</span>)</span><br><span class="line">                uf_Bob.union(i-<span class="number">1</span>, j-<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#再连接Alice</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> edge1:</span><br><span class="line">            <span class="keyword">if</span> uf_Alice.is_connected(i-<span class="number">1</span>, j-<span class="number">1</span>):</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uf_Alice.union(i-<span class="number">1</span>, j-<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#再连接Bob</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> edge2:</span><br><span class="line">            <span class="keyword">if</span> uf_Bob.is_connected(i-<span class="number">1</span>, j-<span class="number">1</span>):</span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                uf_Bob.union(i-<span class="number">1</span>, j-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> uf_Alice.count == <span class="number">1</span> <span class="keyword">and</span> uf_Bob.count == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/path-with-minimum-effort/submissions/">1631</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumEffortPath</span>(<span class="params">self, heights: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        row, col = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> row == <span class="number">1</span> <span class="keyword">and</span> col == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        weighted_edges = []</span><br><span class="line">        n = row*col</span><br><span class="line">        <span class="comment">#通过往左往上构造边</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                index = i * col + j</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span>: weighted_edges.append((index - col, index, <span class="built_in">abs</span>(heights[i][j] - heights[i-<span class="number">1</span>][j])))</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span>: weighted_edges.append((index - <span class="number">1</span>, index, <span class="built_in">abs</span>(heights[i][j] - heights[i][j-<span class="number">1</span>])))</span><br><span class="line">        weighted_edges.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>])</span><br><span class="line">        uf = Union_Find(n)</span><br><span class="line">        <span class="keyword">for</span> i, j, w <span class="keyword">in</span> weighted_edges:</span><br><span class="line">            uf.union(i, j)</span><br><span class="line">            <span class="keyword">if</span> uf.is_connected(<span class="number">0</span>, row*col-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure><blockquote><p>尝试了把sorted用改写的三元组版本的优先队列来替代，但是效果没有内置函数sort来得好唉</p><p>并查集相关的题目不止是并查集这么简单，并查集只是可以用来辅助的一种数据结构！</p></blockquote><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&amp;mid=2247484751&amp;idx=1&amp;sn=a873c1f51d601bac17f5078c408cc3f6&amp;chksm=9bd7fb47aca07251dd9146e745b4cc5cfdbc527abe93767691732dfba166dfc02fbb7237ddbf&amp;scene=21#wechat_redirect">Union-Find 并查集算法详解</a></p></blockquote><ul><li>主要解决图论中动态连通性问题</li><li>Key poits: <code>union</code> and <code>connected</code></li><li>并查集也被称为不相交集数据结构。顾名思义，并查集主要操作是合并与查询，它是把初始不相交的集合经过多次合并操作后合并为一个大集合，然后可以通过查询判断两个元素是否已经在同一个集合中了。</li><li>并查集的应用场景一般就是动态连通性的判断，例如判断网络中的两台电脑是否连通，在程序中判断两个变量名是否指向同一内存地址等。</li></ul><blockquote><p><strong><em><a href="https://www.cnblogs.com/yscl/p/10185293.html">Python 实现并查集</a></em></strong></p><p><strong><em><a href="http://siliconraleigh.com/2018/01/18/Union-Find/">并查集与合并-查找算法的 Python 实现</a></em></strong></p><p>算法4—— 1.5 案例研究：union-find 算法</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并查集算法&quot;&gt;&lt;a href=&quot;#并查集算法&quot; class=&quot;headerlink&quot; title=&quot;并查集算法&quot;&gt;&lt;/a&gt;并查集算法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[X] 动手使用python实现&lt;code&gt;并查集&lt;/code&gt;4个版本🚀️&lt;/li&gt;
&lt;li&gt;[ ] 应用刷题！🎉️：刷完&lt;a href=&quot;https://leetcode-cn.com/tag/union-find/&quot;&gt;并查集tag&lt;/a&gt;再勾（7/39）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://yihang-li.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://yihang-li.github.io/tags/Leetcode/"/>
    
      <category term="Union Find" scheme="https://yihang-li.github.io/tags/Union-Find/"/>
    
  </entry>
  
  <entry>
    <title>Graph</title>
    <link href="https://yihang-li.github.io/2021/01/23/Leetcode_Graph/"/>
    <id>https://yihang-li.github.io/2021/01/23/Leetcode_Graph/</id>
    <published>2021-01-23T12:17:22.327Z</published>
    <updated>2021-03-30T07:09:07.997Z</updated>
    
    <content type="html"><![CDATA[<ul><li>[X] 👀️ 图在Python中的表示方法有哪些？</li><li>[X] 🎉️ DFS</li><li>[X] BFS</li><li>[X] Priority Queue by heap</li><li>[ ] Dijkstra</li></ul><a id="more"></a><h2 id="灵魂发问"><a href="#灵魂发问" class="headerlink" title="灵魂发问"></a>灵魂发问</h2><blockquote><p>要实现图相关的算法涉及到一个问题：图这种数据结构在Python中怎么表示？—-&gt; Task1: 弄清python中图的相关表示</p></blockquote><h2 id="图在Python中的表示方法"><a href="#图在Python中的表示方法" class="headerlink" title="图在Python中的表示方法"></a>图在Python中的表示方法</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><blockquote><p>这个应该蛮简单的</p></blockquote><h3 id="邻接链表"><a href="#邻接链表" class="headerlink" title="邻接链表"></a>邻接链表</h3><blockquote><p>Python没有指针，那么邻接链表怎么表示出来呢，看样子这部分是重点</p></blockquote><p>解决方案：</p><blockquote><p>参考这篇：<a href="https://blog.csdn.net/u014281392/article/details/79120406">常见的图结构表示(python)</a></p><p>还有这个：<a href="https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/18_%E5%9B%BE%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/graph/">Python数据结构与算法视频教程</a></p></blockquote><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><h3 id="Intuitive-——-走迷宫"><a href="#Intuitive-——-走迷宫" class="headerlink" title="Intuitive —— 走迷宫"></a>Intuitive —— 走迷宫</h3><blockquote><p>Tremaux 搜索 （迷宫-图， 通道-边， 路口-顶点）</p><ul><li>选择一条未标记过的通道，在走过的路上铺一条绳子</li><li>标记所有第一次路过的路口和通道</li><li>当来到一个标记过的路口时回退到上个路口</li><li>当回退到的路口已没有可走的通道时继续回退</li></ul><blockquote><p>划重点：<code>绳子</code>, <code>标记</code></p></blockquote></blockquote><h3 id="动手实现"><a href="#动手实现" class="headerlink" title="动手实现"></a>动手实现</h3><h4 id="Version1——递归"><a href="#Version1——递归" class="headerlink" title="Version1——递归"></a>Version1——递归</h4><blockquote><p>和Tremaux类似，访问其中一个顶点时：</p><ul><li>标记它为已访问</li><li>递归(<code>绳子</code>)地访问它所有未标记过的邻结点</li></ul><p>Note: 若图是连通的，则每个顶点都会被访问到</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#递归</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DepthFirstSearch</span>(<span class="params">G, s</span>):</span></span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">G, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">            <span class="comment">#print(s) #入栈时访问</span></span><br><span class="line">            marked.add(s)</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> G[s]:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                dfs(G, node)</span><br><span class="line">        print(s) <span class="comment"># 出栈时访问</span></span><br><span class="line">    dfs(G, s)</span><br></pre></td></tr></table></figure><h4 id="Version2-——-辅助栈"><a href="#Version2-——-辅助栈" class="headerlink" title="Version2 —— 辅助栈"></a>Version2 —— 辅助栈</h4><blockquote><p>注意每一次只入栈一个未标记的邻结点，最后一个未标记的邻结点都找不到了才出栈访问</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#辅助栈</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DepthFirstSearch</span>(<span class="params">G, s</span>):</span></span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    stack = [s]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        tmp = stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">            <span class="comment"># print(tmp) # 入栈时访问</span></span><br><span class="line">            marked.add(tmp)</span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> G[tmp]:</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                <span class="comment"># print(neighbor)</span></span><br><span class="line">                stack.append(neighbor)</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            res = stack.pop()</span><br><span class="line">            print(res) <span class="comment"># 出栈时访问</span></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>测试用例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">G = &#123;</span><br><span class="line">    <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;F&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;G&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;E&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;E&#x27;</span>: [<span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;F&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;F&#x27;</span>: [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;E&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;G&#x27;</span>: [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;H&#x27;</span>: [<span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;I&#x27;</span>: [<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>算法遍历边和访问顶点的顺序与图的表示是有关的，而不是仅与图的结构或算法有关</p></blockquote><ul><li><p>测试结果</p></li><li><p>[X] 入栈时访问/出栈时访问</p><ul><li>[X] 递归</li><li>[X] 显式栈</li></ul></li></ul><h3 id="应用刷题"><a href="#应用刷题" class="headerlink" title="应用刷题"></a>应用刷题</h3><blockquote><p>在应用的时候并非按部就班的套以上实现代码，重点在于算法思想的应用</p><p>这是区别于并查集的地方，原因在于并查集算是一种数据结构，而这个是实打实的算法</p></blockquote><ul><li>[X] <a href="https://leetcode-cn.com/problems/number-of-islands/">200</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid: List[List[<span class="built_in">str</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment">#DFS</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            grid[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> grid[i-<span class="number">1</span>][j] == <span class="string">&quot;1&quot;</span>: dfs(i-<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">if</span> i &lt; row - <span class="number">1</span> <span class="keyword">and</span> grid[i+<span class="number">1</span>][j] == <span class="string">&quot;1&quot;</span>: dfs(i+<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> grid[i][j-<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>: dfs(i, j-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> j &lt; col - <span class="number">1</span> <span class="keyword">and</span> grid[i][j+<span class="number">1</span>] == <span class="string">&quot;1&quot;</span>: dfs(i, j+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        row, col = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    res += <span class="number">1</span></span><br><span class="line">                    dfs(i, j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment">#DFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        left = self.minDepth(root.left)</span><br><span class="line">        right = self.minDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">or</span> <span class="keyword">not</span> root.right: <span class="keyword">return</span> <span class="number">1</span> + left + right</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(left, right)</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索-（BFS）"><a href="#广度优先搜索-（BFS）" class="headerlink" title="广度优先搜索 （BFS）"></a>广度优先搜索 （BFS）</h2><blockquote><p>启发问题：单点最短路径   DFS无所作为，BFS应运而生</p><p>一组人一起朝各个方向走迷宫，每个人都有自己的绳子。出现新岔路时，一个探索者分裂为更多的人来探索；两个探索者相遇时合体，继续使用先到达者的绳子</p></blockquote><h3 id="动手实现-1"><a href="#动手实现-1" class="headerlink" title="动手实现"></a>动手实现</h3><h4 id="辅助队列-（FIFO）"><a href="#辅助队列-（FIFO）" class="headerlink" title="辅助队列 （FIFO）"></a>辅助队列 （FIFO）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BreathFirstSearch</span>(<span class="params">G, s</span>):</span></span><br><span class="line">    marked = <span class="built_in">set</span>()</span><br><span class="line">    queue = collections.deque()</span><br><span class="line">    queue.append(s)</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        tmp = queue.popleft()</span><br><span class="line">        <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">            print(tmp) <span class="comment"># 访问</span></span><br><span class="line">            marked.add(tmp)</span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> G[tmp]:</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                queue.append(neighbor)</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><ul><li>测试用例同DFS</li><li><p>测试结果</p></li><li><p>[X] 一种访问方式</p></li></ul><h3 id="应用刷题-1"><a href="#应用刷题-1" class="headerlink" title="应用刷题"></a>应用刷题</h3><ul><li>[X] <a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment"># BFS</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="comment"># marked = set()</span></span><br><span class="line">        <span class="comment"># marked.add(root)</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                tmp = queue.popleft()</span><br><span class="line">                <span class="comment"># if tmp not in marked:</span></span><br><span class="line">                    <span class="comment"># marked.add(tmp)</span></span><br><span class="line">                <span class="keyword">if</span> tmp.left: queue.append(tmp.left)</span><br><span class="line">                <span class="keyword">if</span> tmp.right: queue.append(tmp.right)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> (tmp.left <span class="keyword">or</span> tmp.right):</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">            res += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/open-the-lock/">752</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">children</span>(<span class="params">s</span>):</span></span><br><span class="line">    a, b, c, d = <span class="built_in">int</span>(s[<span class="number">0</span>]), <span class="built_in">int</span>(s[<span class="number">1</span>]), <span class="built_in">int</span>(s[<span class="number">2</span>]), <span class="built_in">int</span>(s[<span class="number">3</span>])</span><br><span class="line">    child = []</span><br><span class="line">    <span class="comment">#first</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">0</span>: child.append(<span class="built_in">str</span>(a-<span class="number">1</span>)+s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">else</span>: child.append(<span class="string">&#x27;9&#x27;</span>+s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">9</span>: child.append(<span class="built_in">str</span>(a+<span class="number">1</span>)+s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">else</span>: child.append(<span class="string">&#x27;0&#x27;</span>+s[<span class="number">1</span>:])</span><br><span class="line">    <span class="comment">#second</span></span><br><span class="line">    <span class="keyword">if</span> b &gt; <span class="number">0</span>: child.append(s[<span class="number">0</span>] + <span class="built_in">str</span>(b-<span class="number">1</span>)+s[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[<span class="number">0</span>] + <span class="string">&#x27;9&#x27;</span>+ s[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">if</span> b &lt; <span class="number">9</span>: child.append(s[<span class="number">0</span>] + <span class="built_in">str</span>(b+<span class="number">1</span>)+s[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[<span class="number">0</span>]+<span class="string">&#x27;0&#x27;</span>+s[<span class="number">2</span>:])</span><br><span class="line">    <span class="comment">#third</span></span><br><span class="line">    <span class="keyword">if</span> c &gt; <span class="number">0</span>: child.append(s[<span class="number">0</span>:<span class="number">2</span>] + <span class="built_in">str</span>(c-<span class="number">1</span>)+s[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[<span class="number">0</span>:<span class="number">2</span>]+<span class="string">&#x27;9&#x27;</span>+s[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> c &lt; <span class="number">9</span>: child.append(s[<span class="number">0</span>:<span class="number">2</span>]+<span class="built_in">str</span>(c+<span class="number">1</span>)+s[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[<span class="number">0</span>:<span class="number">2</span>]+<span class="string">&#x27;0&#x27;</span>+s[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#fourth</span></span><br><span class="line">    <span class="keyword">if</span> d &gt; <span class="number">0</span>: child.append(s[:<span class="number">3</span>]+<span class="built_in">str</span>(d-<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[:<span class="number">3</span>]+<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> d &lt; <span class="number">9</span>: child.append(s[:<span class="number">3</span>]+<span class="built_in">str</span>(d+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[:<span class="number">3</span>]+<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openLock</span>(<span class="params">self, deadends: List[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        root = <span class="string">&#x27;0000&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> target == root: <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">in</span> deadends: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        queue.append(root)</span><br><span class="line">        marked = <span class="built_in">set</span>()</span><br><span class="line">        marked.add(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(queue)):</span><br><span class="line">                tmp = queue.popleft()</span><br><span class="line">                child = children(tmp)</span><br><span class="line">                <span class="keyword">for</span> ch <span class="keyword">in</span> child:</span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> deadends <span class="keyword">and</span> ch <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                        queue.append(ch)</span><br><span class="line">                        marked.add(ch)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> queue: <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>优化思路: 双向BFS (前提：知道终点在哪)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">children</span>(<span class="params">s</span>):</span></span><br><span class="line">    a, b, c, d = <span class="built_in">int</span>(s[<span class="number">0</span>]), <span class="built_in">int</span>(s[<span class="number">1</span>]), <span class="built_in">int</span>(s[<span class="number">2</span>]), <span class="built_in">int</span>(s[<span class="number">3</span>])</span><br><span class="line">    child = []</span><br><span class="line">    <span class="comment">#first</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">0</span>: child.append(<span class="built_in">str</span>(a-<span class="number">1</span>)+s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">else</span>: child.append(<span class="string">&#x27;9&#x27;</span>+s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">9</span>: child.append(<span class="built_in">str</span>(a+<span class="number">1</span>)+s[<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">else</span>: child.append(<span class="string">&#x27;0&#x27;</span>+s[<span class="number">1</span>:])</span><br><span class="line">    <span class="comment">#second</span></span><br><span class="line">    <span class="keyword">if</span> b &gt; <span class="number">0</span>: child.append(s[<span class="number">0</span>] + <span class="built_in">str</span>(b-<span class="number">1</span>)+s[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[<span class="number">0</span>] + <span class="string">&#x27;9&#x27;</span>+ s[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">if</span> b &lt; <span class="number">9</span>: child.append(s[<span class="number">0</span>] + <span class="built_in">str</span>(b+<span class="number">1</span>)+s[<span class="number">2</span>:])</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[<span class="number">0</span>]+<span class="string">&#x27;0&#x27;</span>+s[<span class="number">2</span>:])</span><br><span class="line">    <span class="comment">#third</span></span><br><span class="line">    <span class="keyword">if</span> c &gt; <span class="number">0</span>: child.append(s[<span class="number">0</span>:<span class="number">2</span>] + <span class="built_in">str</span>(c-<span class="number">1</span>)+s[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[<span class="number">0</span>:<span class="number">2</span>]+<span class="string">&#x27;9&#x27;</span>+s[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> c &lt; <span class="number">9</span>: child.append(s[<span class="number">0</span>:<span class="number">2</span>]+<span class="built_in">str</span>(c+<span class="number">1</span>)+s[-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[<span class="number">0</span>:<span class="number">2</span>]+<span class="string">&#x27;0&#x27;</span>+s[-<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#fourth</span></span><br><span class="line">    <span class="keyword">if</span> d &gt; <span class="number">0</span>: child.append(s[:<span class="number">3</span>]+<span class="built_in">str</span>(d-<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[:<span class="number">3</span>]+<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> d &lt; <span class="number">9</span>: child.append(s[:<span class="number">3</span>]+<span class="built_in">str</span>(d+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">else</span>: child.append(s[:<span class="number">3</span>]+<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openLock</span>(<span class="params">self, deadends: List[<span class="built_in">str</span>], target: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        root = <span class="string">&#x27;0000&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> target == root: <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">in</span> deadends: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment">#双向BFS</span></span><br><span class="line">        q1, q2 = <span class="built_in">set</span>(), <span class="built_in">set</span>()</span><br><span class="line">        marked = <span class="built_in">set</span>()</span><br><span class="line">        q1.add(root)</span><br><span class="line">        q2.add(target)</span><br><span class="line">        <span class="keyword">while</span> q1 <span class="keyword">and</span> q2:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(q1) &gt; <span class="built_in">len</span>(q2):</span><br><span class="line">                q1, q2 = q2, q1</span><br><span class="line">            tmp = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> p <span class="keyword">in</span> q1:</span><br><span class="line">                <span class="keyword">if</span> p <span class="keyword">in</span> q2:</span><br><span class="line">                    <span class="keyword">return</span> res</span><br><span class="line">                marked.add(p)</span><br><span class="line">                child = children(p)</span><br><span class="line">                <span class="keyword">for</span> ch <span class="keyword">in</span> child:</span><br><span class="line">                    <span class="keyword">if</span> ch <span class="keyword">not</span> <span class="keyword">in</span> deadends <span class="keyword">and</span> ch <span class="keyword">not</span> <span class="keyword">in</span> marked:</span><br><span class="line">                        tmp.add(ch)</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            q1 = q2</span><br><span class="line">            q2 = tmp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>DFS-线-Solo-递归好写</p><p>BFS-面-团战-找最短路径适用</p></blockquote><p>暂时到这儿了，有空再更新👀️</p><h2 id="优先队列-Prior-Queue"><a href="#优先队列-Prior-Queue" class="headerlink" title="优先队列 Prior Queue"></a>优先队列 Prior Queue</h2><p>一种抽象数据类型，实现<code>删除最小元素</code> （<code>删除最大元素</code>可通过相应转化改写得到）和 <code>插入元素</code></p><h3 id="API-堆实现-Heap"><a href="#API-堆实现-Heap" class="headerlink" title="API  (堆实现 (Heap))"></a>API  (堆实现 (Heap))</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#API</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinPQ</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> <span class="comment">#初始化一个优先队列</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, v</span>):</span> <span class="comment">#向优先队列中插入一个元素</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mini</span>(<span class="params">self</span>):</span> <span class="comment"># 返回最小元素</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delMin</span>(<span class="params">self</span>):</span> <span class="comment">#删除并返回最小元素</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span> <span class="comment">#返回队列是否为空</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span> <span class="comment"># 返回优先队列中的元素个数</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">less</span>(<span class="params">self, i, j</span>):</span> <span class="comment"># 堆实现的比较方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exch</span>(<span class="params">self, i, j</span>):</span> <span class="comment"># 堆实现的交换方法</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swim</span>(<span class="params">self, k</span>):</span> <span class="comment"># 由下至上的堆有序化实现</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sink</span>(<span class="params">self, k</span>):</span> <span class="comment"># 由上至下的堆有序化实现</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>最大堆（大顶堆) for MaxPQ; 最小堆（小顶堆）for MinPQ</p><ul><li>优先队列由一个基于堆的完全二叉树表示，存储于数组pq[1:N]中, pq[0]没有使用</li><li>在Insert中，我们将N加一并把新元素添加在数组最后，然后用swim()恢复堆的秩序</li><li>在delMin()中，我们从pq[1]得到需要返回的元素，然后将pq[N]移动到pq[1]，将N减1并用sink()恢复堆的秩序</li><li>对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过$(lgN+1)$次比较，删除最小元素的操作需要不超过$ 2lgN$次比较</li></ul></blockquote><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinPQ</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> <span class="comment">#初始化一个优先队列</span></span><br><span class="line">        self.pq = [<span class="number">0</span>]</span><br><span class="line">        self.N = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span> <span class="comment">#返回队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> self.N == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span> <span class="comment"># 返回优先队列中的元素个数</span></span><br><span class="line">        <span class="keyword">return</span> self.N</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mini</span>(<span class="params">self</span>):</span> <span class="comment"># 返回最小元素</span></span><br><span class="line">        <span class="keyword">if</span> self.N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.pq[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, v</span>):</span> <span class="comment">#向优先队列中插入一个元素</span></span><br><span class="line">        self.pq.append(v)</span><br><span class="line">        self.N += <span class="number">1</span></span><br><span class="line">        self.swim(self.N)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delMin</span>(<span class="params">self</span>):</span> <span class="comment">#删除并返回最小元素</span></span><br><span class="line">        <span class="keyword">if</span> self.N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = self.pq[<span class="number">1</span>]</span><br><span class="line">        self.exch(<span class="number">1</span>, self.N)</span><br><span class="line">        self.pq.pop()</span><br><span class="line">        self.N -= <span class="number">1</span></span><br><span class="line">        self.sink(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">less</span>(<span class="params">self, i, j</span>):</span> <span class="comment"># 堆实现的比较方法</span></span><br><span class="line">        <span class="keyword">return</span> self.pq[i] &lt; self.pq[j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exch</span>(<span class="params">self, i, j</span>):</span> <span class="comment"># 堆实现的交换方法</span></span><br><span class="line">        self.pq[i], self.pq[j] = self.pq[j], self.pq[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swim</span>(<span class="params">self, k</span>):</span> <span class="comment"># 由下至上的堆有序化实现</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> self.less(k//<span class="number">2</span>, k):</span><br><span class="line">            self.exch(k//<span class="number">2</span>, k)</span><br><span class="line">            k = k//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sink</span>(<span class="params">self, k</span>):</span> <span class="comment"># 由上至下的堆有序化实现</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">2</span>*k &lt;= self.N:</span><br><span class="line">            j = <span class="number">2</span>*k</span><br><span class="line">            <span class="keyword">if</span> j &lt; self.N <span class="keyword">and</span> <span class="keyword">not</span> self.less(j, j+<span class="number">1</span>):</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.less(k, j): <span class="keyword">break</span></span><br><span class="line">            self.exch(k, j)</span><br><span class="line">            k = j</span><br></pre></td></tr></table></figure><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PQ = MinPQ()</span><br><span class="line">PQ.insert(<span class="number">7</span>)</span><br><span class="line">PQ.insert(<span class="number">6</span>)</span><br><span class="line">PQ.insert(<span class="number">5</span>)</span><br><span class="line">PQ.insert(<span class="number">4</span>)</span><br><span class="line">PQ.insert(<span class="number">3</span>)</span><br><span class="line">PQ.insert(<span class="number">2</span>)</span><br><span class="line">PQ.insert(<span class="number">1</span>)</span><br><span class="line">PQ.insert(<span class="number">0</span>)</span><br><span class="line">PQ.insert(-<span class="number">1</span>)</span><br><span class="line">PQ.insert(-<span class="number">2</span>)</span><br><span class="line">PQ.pq</span><br><span class="line"><span class="comment"># %% run 10 times</span></span><br><span class="line">PQ.delMin()</span><br><span class="line">PQ.pq</span><br></pre></td></tr></table></figure><blockquote><p>测试结果符合</p></blockquote><h3 id="应用刷题-2"><a href="#应用刷题-2" class="headerlink" title="应用刷题"></a>应用刷题</h3><ul><li>[X] <a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/">剑指Offer41</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 改写MinPQ --&gt; MaxPQ</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span> <span class="comment">#初始化一个优先队列</span></span><br><span class="line">        self.pq = [<span class="number">0</span>]</span><br><span class="line">        self.N = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span> <span class="comment">#返回队列是否为空</span></span><br><span class="line">        <span class="keyword">return</span> self.N == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span>(<span class="params">self</span>):</span> <span class="comment"># 返回优先队列中的元素个数</span></span><br><span class="line">        <span class="keyword">return</span> self.N</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxi</span>(<span class="params">self</span>):</span> <span class="comment"># 返回最大元素</span></span><br><span class="line">        <span class="keyword">if</span> self.N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> self.pq[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, v</span>):</span> <span class="comment">#向优先队列中插入一个元素</span></span><br><span class="line">        self.pq.append(v)</span><br><span class="line">        self.N += <span class="number">1</span></span><br><span class="line">        self.swim(self.N)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delMax</span>(<span class="params">self</span>):</span> <span class="comment">#删除并返回最大元素</span></span><br><span class="line">        <span class="keyword">if</span> self.N == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        res = self.pq[<span class="number">1</span>]</span><br><span class="line">        self.exch(<span class="number">1</span>, self.N)</span><br><span class="line">        self.pq.pop()</span><br><span class="line">        self.N -= <span class="number">1</span></span><br><span class="line">        self.sink(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">less</span>(<span class="params">self, i, j</span>):</span> <span class="comment"># 堆实现的比较方法</span></span><br><span class="line">        <span class="keyword">return</span> self.pq[i] &lt; self.pq[j]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exch</span>(<span class="params">self, i, j</span>):</span> <span class="comment"># 堆实现的交换方法</span></span><br><span class="line">        self.pq[i], self.pq[j] = self.pq[j], self.pq[i]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swim</span>(<span class="params">self, k</span>):</span> <span class="comment"># 由下至上的堆有序化实现</span></span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">1</span> <span class="keyword">and</span> self.less(k//<span class="number">2</span>, k):</span><br><span class="line">            self.exch(k//<span class="number">2</span>, k)</span><br><span class="line">            k = k//<span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sink</span>(<span class="params">self, k</span>):</span> <span class="comment"># 由上至下的堆有序化实现</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">2</span>*k &lt;= self.N:</span><br><span class="line">            j = <span class="number">2</span>*k</span><br><span class="line">            <span class="keyword">if</span> j &lt; self.N <span class="keyword">and</span> self.less(j, j+<span class="number">1</span>):</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.less(k, j): <span class="keyword">break</span></span><br><span class="line">            self.exch(k, j)</span><br><span class="line">            k = j</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#构造一个大顶堆，一个小顶堆，中位数在最后的maxi和mini中求得</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.maxpq = MaxPQ()</span><br><span class="line">        self.minpq = MinPQ()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.maxpq.N == self.minpq.N:</span><br><span class="line">            <span class="keyword">if</span> self.minpq.N &gt;= <span class="number">1</span> <span class="keyword">and</span> num &gt; self.minpq.mini():</span><br><span class="line">                num, self.minpq.pq[<span class="number">1</span>] = self.minpq.pq[<span class="number">1</span>], num</span><br><span class="line">                self.minpq.sink(<span class="number">1</span>)</span><br><span class="line">            self.maxpq.insert(num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> num &lt; self.maxpq.maxi():</span><br><span class="line">                num, self.maxpq.pq[<span class="number">1</span>] = self.maxpq.pq[<span class="number">1</span>], num</span><br><span class="line">                self.maxpq.sink(<span class="number">1</span>)</span><br><span class="line">            self.minpq.insert(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span>(<span class="params">self</span>) -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> self.maxpq.N == self.minpq.N:</span><br><span class="line">            <span class="keyword">return</span> (self.maxpq.maxi() + self.minpq.mini())/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.maxpq.maxi()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/last-stone-weight/">1046</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 实例化MaxPQ</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeight</span>(<span class="params">self, stones: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        maxpq = MaxPQ()</span><br><span class="line">        <span class="keyword">for</span> stone <span class="keyword">in</span> stones:</span><br><span class="line">            maxpq.insert(stone)</span><br><span class="line">        <span class="keyword">while</span> maxpq.N &gt; <span class="number">1</span>:</span><br><span class="line">            pick1 = maxpq.delMax()</span><br><span class="line">            pick2 = maxpq.delMax()</span><br><span class="line">            <span class="keyword">if</span> pick1 &lt;= pick2:</span><br><span class="line">                maxpq.insert(pick2 - pick1)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                maxpq.insert(pick1 - pick2)</span><br><span class="line">        <span class="keyword">return</span> maxpq.maxi()</span><br></pre></td></tr></table></figure><ul><li>[X] <a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#改写三元组版本MinPQ ----&gt; 实质BFS with MinPQ (3-ele-tuple-version)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment">###BFS with Priority Queue</span></span><br><span class="line">        pq = MinPQ()</span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        pq.insert(v=(grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        visited.add((<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pq.N &gt; <span class="number">0</span>:</span><br><span class="line">            v, i, j = pq.delmini()</span><br><span class="line">            res = <span class="built_in">max</span>(res, v)</span><br><span class="line">            <span class="keyword">if</span> i == n-<span class="number">1</span> <span class="keyword">and</span> j == n-<span class="number">1</span>: <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> visited: visited.add((i, j))</span><br><span class="line">            <span class="keyword">if</span> i &lt; n-<span class="number">1</span> <span class="keyword">and</span> (i+<span class="number">1</span>, j) <span class="keyword">not</span> <span class="keyword">in</span> visited: pq.insert((grid[i+<span class="number">1</span>][j], i+<span class="number">1</span>, j))</span><br><span class="line">            <span class="keyword">if</span> j &lt; n-<span class="number">1</span> <span class="keyword">and</span> (i, j+<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> visited: pq.insert((grid[i][j+<span class="number">1</span>], i, j+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> (i-<span class="number">1</span>, j) <span class="keyword">not</span> <span class="keyword">in</span> visited: pq.insert((grid[i-<span class="number">1</span>][j], i-<span class="number">1</span>, j))</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> (i, j-<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> visited: pq.insert((grid[i][j-<span class="number">1</span>], i, j-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="Python-Standard-Library-——-heapq"><a href="#Python-Standard-Library-——-heapq" class="headerlink" title="Python Standard Library —— heapq"></a>Python Standard Library —— <a href="https://docs.python.org/3/library/heapq.html">heapq</a></h3><ul><li>MinPQ</li><li>zero-based Indexing</li><li>pop method returns the smallest item</li><li>heap[0] is the smallest item, and heap.sort() maintains the heap invariant</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Push the value item onto the heap, maintaining the heap invariant.</span></span><br><span class="line">heapq.heappush(heap, item)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Pop and return the smallest item from the heap, maintaining the heap invariant.</span></span><br><span class="line"><span class="comment">#If the heap is empty, IndexError is raised.</span></span><br><span class="line"><span class="comment">#To access the smallest item without popping it, use heap[0].</span></span><br><span class="line">heapq.heappop(heap)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Push item on the heap, then pop and return the smallest item from the heap.</span></span><br><span class="line"><span class="comment">#The combined action runs more efficiently than heappush()</span></span><br><span class="line"><span class="comment">#followed by a separate call to heappop().</span></span><br><span class="line">heapq.heappushpop(heap, item)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Transform list x into a heap, in-place, in linear time.</span></span><br><span class="line">heapq.heapify(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Pop and return the smallest item from the heap, and also push the new item.</span></span><br><span class="line"><span class="comment">#The heap size doesn’t change. If the heap is empty, IndexError is raised.</span></span><br><span class="line"><span class="comment">#This one step operation is more efficient than a heappop() followed by heappush()</span></span><br><span class="line"><span class="comment">#and can be more appropriate when using a fixed-size heap.</span></span><br><span class="line"><span class="comment">#The pop/push combination always returns an element from the heap and replaces it with item.</span></span><br><span class="line"><span class="comment">#The value returned may be larger than the item added. If that isn’t desired,</span></span><br><span class="line"><span class="comment">#consider using heappushpop() instead. Its push/pop combination</span></span><br><span class="line"><span class="comment">#returns the smaller of the two values, leaving the larger value on the heap.</span></span><br><span class="line">heapq.heapreplace(heap, item)</span><br></pre></td></tr></table></figure><p>The module also offers three general purpose functions based on heaps:</p><ul><li>heapq.merge(<em>*iterables</em>, <em>key=None</em>, <em>reverse=False</em>)</li><li>heapq.nlargest(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</li><li>heapq.nsmallest(<em>n</em>, <em>iterable</em>, <em>key=None</em>)</li></ul><p>See <a href="https://github.com/python/cpython/blob/3.9/Lib/heapq.py">Souce Code: cpython/Lib/heapq.py</a></p><ul><li>[X] <a href="https://leetcode-cn.com/problems/swim-in-rising-water/">778</a> by using heapq</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">swimInWater</span>(<span class="params">self, grid: List[List[<span class="built_in">int</span>]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="comment">#Using heapq</span></span><br><span class="line">        n = <span class="built_in">len</span>(grid)</span><br><span class="line">        pq = [(grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> pq:</span><br><span class="line">            v, i, j = heapq.heappop(pq)</span><br><span class="line">            res = <span class="built_in">max</span>(res, v)</span><br><span class="line">            <span class="keyword">if</span> i == n-<span class="number">1</span> <span class="keyword">and</span> j == n-<span class="number">1</span>: <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">if</span> (i, j) <span class="keyword">not</span> <span class="keyword">in</span> visited: visited.add((i, j))</span><br><span class="line">            <span class="keyword">if</span> i &lt; n-<span class="number">1</span> <span class="keyword">and</span> (i+<span class="number">1</span>, j) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                heapq.heappush(pq, (grid[i+<span class="number">1</span>][j], i+<span class="number">1</span>, j))</span><br><span class="line">            <span class="keyword">if</span> j &lt; n-<span class="number">1</span> <span class="keyword">and</span> (i, j+<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                heapq.heappush(pq, (grid[i][j+<span class="number">1</span>], i, j+<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> (i-<span class="number">1</span>, j) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                heapq.heappush(pq, (grid[i-<span class="number">1</span>][j], i-<span class="number">1</span>, j))</span><br><span class="line">            <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> (i, j-<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                heapq.heappush(pq, (grid[i][j-<span class="number">1</span>], i, j-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><ul><li>Like BFS</li><li><code>Prior Queue</code> (use <code>heap</code>)</li><li>Greedy</li><li>Only consider distance from source</li><li>Non-negative weight on edges</li></ul><h3 id="动手实现-2"><a href="#动手实现-2" class="headerlink" title="动手实现"></a>动手实现</h3><h3 id="应用刷题-3"><a href="#应用刷题-3" class="headerlink" title="应用刷题"></a>应用刷题</h3><h2 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h2><ul><li>Also consider distance to end (approximate value, e.g. Euclidian Dist)</li><li>Bias-version BFS</li></ul><h3 id="动手实现-3"><a href="#动手实现-3" class="headerlink" title="动手实现"></a>动手实现</h3><h3 id="应用刷题-4"><a href="#应用刷题-4" class="headerlink" title="应用刷题"></a>应用刷题</h3><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote><p>《算法4》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;[X] 👀️ 图在Python中的表示方法有哪些？&lt;/li&gt;
&lt;li&gt;[X] 🎉️ DFS&lt;/li&gt;
&lt;li&gt;[X] BFS&lt;/li&gt;
&lt;li&gt;[X] Priority Queue by heap&lt;/li&gt;
&lt;li&gt;[ ] Dijkstra&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://yihang-li.github.io/categories/Leetcode/"/>
    
    
      <category term="Leetcode" scheme="https://yihang-li.github.io/tags/Leetcode/"/>
    
      <category term="Graph" scheme="https://yihang-li.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>MDS6222 Dynamic Programming (Notes 1)</title>
    <link href="https://yihang-li.github.io/2021/01/22/MDS6222_Dynamic_Programming/"/>
    <id>https://yihang-li.github.io/2021/01/22/MDS6222_Dynamic_Programming/</id>
    <published>2021-01-22T07:09:58.109Z</published>
    <updated>2021-03-30T07:09:43.710Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ch1-The-Dynamic-Programming-Algorithm"><a href="#Ch1-The-Dynamic-Programming-Algorithm" class="headerlink" title="Ch1 The Dynamic Programming Algorithm"></a>Ch1 The Dynamic Programming Algorithm</h1><blockquote><p>Life can only be understood going backwards,<br>but it must be lived going forwards.<br>—— Kierkegaard</p></blockquote><a id="more"></a><h2 id="1-1-Introduction"><a href="#1-1-Introduction" class="headerlink" title="1.1 Introduction"></a>1.1 Introduction</h2><h3 id="Basic-Structure-of-Stochastic-Dynamic-Programming"><a href="#Basic-Structure-of-Stochastic-Dynamic-Programming" class="headerlink" title="Basic Structure of Stochastic Dynamic Programming"></a>Basic Structure of Stochastic Dynamic Programming</h3><h4 id="2-Principle-Features-of-DP-👀"><a href="#2-Principle-Features-of-DP-👀" class="headerlink" title="2 Principle Features of DP 👀"></a><strong>2</strong> Principle Features of DP 👀</h4><ul><li>Discrete-time Dynamic Systems</li><li>Cost Function is Additive over Time</li></ul><h4 id="6-Key-Elements-of-DP-Formulation-👀"><a href="#6-Key-Elements-of-DP-Formulation-👀" class="headerlink" title="6 Key Elements of DP Formulation 👀"></a><strong>6</strong> Key Elements of DP Formulation 👀</h4><ul><li><strong><em>Stage</em></strong>  $k$: Finite Horizon, Total Number of Horizon $N$ , time/space/etc.</li><li><strong><em>State</em></strong> $x_k$: Decision Base</li></ul><ul><li><strong><em>Control</em></strong> $u_k \in U_k(x_k)$: Action, Decision, each $u_k$ is selected with knowledge of current state $x_k$</li><li><strong><em>Disturbance</em></strong>  $\omega_k \sim P(\omega_k|x_k, u_k)$: Value of Information, probability distribution of $\omega_k$ does not depend on past values $\omega_{k-1}, \dotsm, \omega_0$, but may depend on $x_k$ and $u_k$</li><li><strong><em><code>Memoryless</code> System Dynamics</em></strong> $x_{k+1} = f_k(x_k, u_k, \omega_k)$: $k$ is time-varied, if removed, then stationary system.  <code>Memoryless</code> is that $f_k$ does not depend on $x_{k-1}, \omega_{k-1}$ and so on.</li><li><strong><em><code>Additive</code> Stage Cost</em></strong>: $g_k(x_k, u_k, \omega_k), k = 0, 1, \dotsm, N-1$<br>   <strong><em>Terminal State</em></strong>: $g_N(x_N)$</li></ul><h4 id="2-Aims-👀"><a href="#2-Aims-👀" class="headerlink" title="2 Aims 👀"></a><strong>2</strong> Aims 👀</h4><ul><li><strong><em>Optimal Policy</em></strong> $\pi^<em> = \left(\mu_0^</em>, \mu_1^<em>, \dotsm, \mu_{N-1}^</em> \right)$: <strong><em>Policy</em></strong> ~ $\pi = \left(\mu_0, \mu_1, \dotsm, \mu_{N-1}\right)$ where $\mu_k$ maps states $x_k$ into controls $u_k = \mu_k(x_k)$ and is such that $\mu_k(x_k) \in U_k(x_k)$ for all $x_k$</li><li><strong><em>Optimimal Cost-to-go Function</em></strong>: Tail Subproblems Defined Recursively</li></ul><blockquote><p>$J_N(x_N) = g_N(x_N)$</p><p>$J_k(x_k) = \min\limits_{u_k \in U_k(x_k)}E_{\omega_k}\{g_k(x_k, u_k, \omega_k)+J_{k+1}(f_k(x_k, u_k, \omega_k))\}$,  $\forall k = 0, 1, \dotsm, N-1$</p></blockquote><h3 id="Where-and-Why-to-Use-Dynamic-Programming"><a href="#Where-and-Why-to-Use-Dynamic-Programming" class="headerlink" title="Where and Why to Use Dynamic Programming"></a>Where and Why to Use Dynamic Programming</h3><p>👀️ What if there exists some optimization problems such that</p><ul><li>Decisions can be <strong><em>Sequentially made in stages</em></strong> and only depend on the state in the current stage.  (<code>Memoryless</code>)</li><li>Stochastic Information can be <strong><em>gradually disclosed in stages</em></strong> and only depends on the state and the decision(action, control) in the current stage. (<code>Memoryless</code>)</li><li>Total costs (Rewards) can be <strong><em>accumulated in stages</em></strong>. (<code>Additive</code>)</li></ul><p>🚀️ Opportunities for more efficient and effective methods: Dynamic Programming (<code>DP</code>)</p><blockquote><p>DP can deal with <strong><em>complex stochastic problems</em></strong> where information about $\omega  $ becomes available in stages, and the decisions are also made in stages and make use of this information.</p></blockquote><h3 id="Example-Inventory-Control"><a href="#Example-Inventory-Control" class="headerlink" title="Example: Inventory Control"></a>Example: Inventory Control</h3><ul><li><strong><em>Stage</em></strong>: Ordering Period: $k$</li><li><strong><em>State</em></strong>: Inventory Level at Period $k$ : $x_k$</li><li><strong><em>Control</em></strong>: Stock ordered at Period $k$ : $u_k \ge 0$</li><li><strong><em>Disturbance</em></strong>: Demand at Period $k$ with given probability distribution: $\omega_k$</li><li><strong><em>System Dynamics</em></strong>: $x_{k+1} = f_k(x_k, u_k, \omega_k) = x_k + u_k - \omega_k$</li><li><strong><em>Stage Cost</em></strong>: $g_k(x_k, u_k, \omega_k) = kI_{u_k&gt;0} + cu_k + h(x_k + u_k - \omega_k)^{+} + p(x_k + u_k - \omega_k)^{-}$<br>Note: costs = setup + ordering + holding + shortage</li><li><strong><em>Terminal Cost</em></strong>: $g_N(x_N) = 0$</li><li><strong><em>Cost Fuction is Additive over Time</em></strong>: $E_{\omega}\{g_N(x_N) + \sum_{k = 0}^{N-1}g_k(x_k, u_k, \omega_k)\}$</li><li><strong><em>Optimization over Policies/Rules(closed-loop)</em></strong>: $u_k = \mu_k(x_k), \text{for} \ k=0, 1, \cdots, N-1$</li></ul><h3 id="Open-loop-vs-Closed-loop-Feedback-Control"><a href="#Open-loop-vs-Closed-loop-Feedback-Control" class="headerlink" title="Open-loop vs Closed-loop (Feedback Control)"></a>Open-loop vs Closed-loop (Feedback Control)</h3><ul><li>In open-loop minimization, we select all controls $u_k$ at once at time 0, without waiting to see the subsequent disturbance $w_k$</li><li>In closed- loop minimization, we postpone selecting control $u_k$ until the last possible moment (time $k$) when the current state $x_k$ will be known, thus can make use of the information of $w_k$ that becomes available in stages</li></ul><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><ol><li>Schedualing (A Deterministic Finite-State Problem);</li><li>Two Game Chess</li></ol><h2 id="1-2-The-Basic-Problem"><a href="#1-2-The-Basic-Problem" class="headerlink" title="1.2 The Basic Problem"></a>1.2 The Basic Problem</h2><p>Given a discrete-time dynamic system</p><script type="math/tex; mode=display">x_{k+1} = f_k(x_k, u_k, \omega_k), \quad k = 0, 1, \cdots, N-1,</script><p>where the state $x_k \in S_k,$ the control $u_k \in U_k(S_k) \sub C_k,$ and the random disturbance $\omega_k \in D_k = P(\cdot|x_k, u_k)$<br>And given an initial state $x_0$ and an admissible policy $\pi = \{\mu_0, \cdots, \mu_{N-1}\},$ for given stage cost function $g_k,$ the expected cost of $\pi$ starting at $x_0$ is</p><script type="math/tex; mode=display">J_\pi(x_0) = E\left\{g_N(x_N) + \sum_{k = 0}^{N-1}g_k(x_k, \mu_k(x_k), \omega_k)\right\}</script><p>An optimal policy $\pi^*$ is one that minimizes this cost:</p><script type="math/tex; mode=display">J_{\pi^*}(x_0) = min_{\pi\in\Pi}J_\pi(x_0),</script><p>where $\Pi$ is the set of all admissible policies.</p><blockquote><p>Note: When produced by DP, $\pi^*$ is independent of $x_0.$</p></blockquote><h3 id="Value-of-Information"><a href="#Value-of-Information" class="headerlink" title="Value of Information"></a>Value of Information</h3><ul><li>In Deterministic Problem, Open-loop is as good as Closed-loop</li><li>Value of Information = $J^<em>_{\text{closed-loop}} - J^</em>_{\text{open-loop}}$  (The reduction in cost)</li><li>Example: Two-Game Chess</li></ul><h3 id="Encoding-Risk-in-the-Cost-Function"><a href="#Encoding-Risk-in-the-Cost-Function" class="headerlink" title="Encoding Risk in the Cost Function"></a>Encoding Risk in the Cost Function</h3><ul><li>As above, one important characteristic of stochastic problems is the possibility of using information with advantage</li><li>The other distinguishing characteristic is the need to take into account <code>risk</code> in the problem formulation.<br>e.g. Expectation and Variance in investment decision<br>e.g. St. Petersburg paradox</li></ul><h2 id="1-3-The-Dynamic-Programming-Algorithm"><a href="#1-3-The-Dynamic-Programming-Algorithm" class="headerlink" title="1.3 The Dynamic Programming Algorithm"></a>1.3 The Dynamic Programming Algorithm</h2><h3 id="Principle-of-Optimality"><a href="#Principle-of-Optimality" class="headerlink" title="Principle of Optimality"></a>Principle of Optimality</h3><p>The DP Algorithm rests on the principle of optimality:<br>Let $\pi^<em> = \{\mu_0^</em>, \cdots, \mu_{N-1}^*\}$ be optimal policy. Consider the “tail subproblem” whereby we are at $x_i$ at time $i$ and wish to minimize the “cost-to-go” from time $i$ to time $N$</p><script type="math/tex; mode=display">E\left\{g_N(x_N) + \sum_{k = i}^{N-1}g_k(x_k, \mu_k(x_k), \omega_k)\right\}</script><p>Then the tail policy is optimal for the tail subproblem. (<code>Optimization of the future does not depend on what we did in past</code>)</p><ul><li><p>The DP algorithm is based on this idea: it proceeds sequentially, by solving all the tail subproblems of a given time length, using the solution of the tail subproblems of shorter time length.</p><ul><li>e.g. deterministic scheduling example: length-2-tail -&gt; length-3-tail -&gt; length-4-original</li><li>e.g. stochastic inventory control example: length-1-tail -&gt; length-2-tail -&gt;  length-$N-k$-tail</li></ul></li><li><blockquote><p><code>One-at-a-time version of Divide and Conquer</code></p></blockquote></li><li>While the original problem requires an optimization over the set of policies, the DP algorithm decomposes the problem into a sequence of minimizations carried out over the set of controls. Each of these minimizations is much simpler than the original problem.</li></ul><h3 id="The-DP-Algorithm"><a href="#The-DP-Algorithm" class="headerlink" title="The DP Algorithm"></a>The DP Algorithm</h3><p><strong>Proposition 1.3.1</strong>: Start with $J_N(x_N) = g_N(x_N)$ and go backwards using :</p><script type="math/tex; mode=display">J_{k}\left(x_{k}\right) =\min _{u_{k} \in U_{k}\left(x_{k}\right)} \underset{\omega_{k}}{E}\left\{g_{k}\left(x_{k}, u_{k}, \omega_{k}\right) + J_{k+1}\left(f_{k}\left(x_{k}, u_{k}, \omega_{k}\right)\right)\right\}, \quad k=0,1, \ldots, N-1</script><p>Then $J_0(x_0),$ generated at the last step, is equal to the optimal cost $J^<em>(x_0)$. Also, the policy $\pi^</em> = \left\{\mu_0^<em>, \ldots, \mu_{N-1}^</em> \right\}$, where $\mu_k^*(x_k)$ minimizes in the right side above for each $x_k$ and $k$, is optimal</p><blockquote><p>Proof by induction that $J_k(x_k)$ is equal to $J_k^*(x_k)$, defined as the optimal cost of the tail subproblem that starts at time $k$ at state $x_k$.</p><p>Note:</p><ul><li>All the tail subproblems are solved (in addition to the original problem)</li><li>Intensive computational requirements</li></ul></blockquote><ul><li>$J_k(x_k)$ : the cost-to-go at state $x_k$ and time $k$, and refer to $J_k$ as the cost-to-go function at time $k$</li><li>e.g. 1.3.1 two ovens</li></ul><h2 id="1-4-State-Augmentation-and-Other-Reformulations"><a href="#1-4-State-Augmentation-and-Other-Reformulations" class="headerlink" title="1.4 State Augmentation and Other Reformulations"></a>1.4 State Augmentation and Other Reformulations</h2><p>Deal with situations where some of the assumptions of the basic problem are violated —-&gt; reformulate into the basic problem format.</p><h3 id="Case1-Time-Lags"><a href="#Case1-Time-Lags" class="headerlink" title="Case1: Time Lags"></a>Case1: Time Lags</h3><h3 id="Case2-Correlated-Disturbances"><a href="#Case2-Correlated-Disturbances" class="headerlink" title="Case2: Correlated Disturbances"></a>Case2: Correlated Disturbances</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ch1-The-Dynamic-Programming-Algorithm&quot;&gt;&lt;a href=&quot;#Ch1-The-Dynamic-Programming-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Ch1 The Dynamic Programming Algorithm&quot;&gt;&lt;/a&gt;Ch1 The Dynamic Programming Algorithm&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Life can only be understood going backwards,&lt;br&gt;but it must be lived going forwards.&lt;br&gt;—— Kierkegaard&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Notes" scheme="https://yihang-li.github.io/categories/Notes/"/>
    
    
      <category term="DP" scheme="https://yihang-li.github.io/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>Implement LARS for Linear and Lasso Regression with Application in Auto-MPG Data Set</title>
    <link href="https://yihang-li.github.io/2021/01/09/Project3_LARS/"/>
    <id>https://yihang-li.github.io/2021/01/09/Project3_LARS/</id>
    <published>2021-01-08T23:08:39.000Z</published>
    <updated>2021-03-30T07:26:32.018Z</updated>
    
    <content type="html"><![CDATA[<!-- <div class="pdfobject-container" data-target="https://drive.google.com/file/d/17x-pyatNiu4QVd6XUqkTKWDtT6tXPPys/view?usp=sharing" data-height="500px"></div> --><div class="pdfobject-container" data-target="https://drive.google.com/file/d/18nTj7E7YKpdfZCXpG0X3aSsR59ziPGFC/preview" data-height="500px"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- &lt;div class=&quot;pdfobject-container&quot; data-target=&quot;https://drive.google.com/file/d/17x-pyatNiu4QVd6XUqkTKWDtT6tXPPys/view?usp=sharing&quot; data-
      
    
    </summary>
    
    
      <category term="Report" scheme="https://yihang-li.github.io/categories/Report/"/>
    
    
      <category term="Report" scheme="https://yihang-li.github.io/tags/Report/"/>
    
  </entry>
  
  <entry>
    <title>Applying Ensemble Method on Cleveland Heart Disease Data Set</title>
    <link href="https://yihang-li.github.io/2021/01/09/Applying_Ensemble_Method_on_Cleveland_Heart_Disease_Data_Set/"/>
    <id>https://yihang-li.github.io/2021/01/09/Applying_Ensemble_Method_on_Cleveland_Heart_Disease_Data_Set/</id>
    <published>2021-01-08T22:55:28.000Z</published>
    <updated>2021-03-30T07:26:48.559Z</updated>
    
    <content type="html"><![CDATA[<div class="pdfobject-container" data-target="https://drive.google.com/file/d/1ZMTx_UoiVuJ-QTwB4RtjSyKL7gHICjLh/preview" data-height="500px"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;pdfobject-container&quot; data-target=&quot;https://drive.google.com/file/d/1ZMTx_UoiVuJ-QTwB4RtjSyKL7gHICjLh/preview&quot; data-height=&quot;500px&quot;
      
    
    </summary>
    
    
      <category term="Report" scheme="https://yihang-li.github.io/categories/Report/"/>
    
    
      <category term="Report" scheme="https://yihang-li.github.io/tags/Report/"/>
    
  </entry>
  
  <entry>
    <title>基于核方法的深圳市房租预测分析</title>
    <link href="https://yihang-li.github.io/2021/01/09/%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"/>
    <id>https://yihang-li.github.io/2021/01/09/%E6%9C%AC%E7%A7%91%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-01-08T22:48:14.000Z</published>
    <updated>2021-03-30T07:26:37.761Z</updated>
    
    <content type="html"><![CDATA[<div class="pdfobject-container" data-target="https://drive.google.com/file/d/1EJ9ozQqEh6vm35fEdR3QRMbyv-yDTNJB/preview" data-height="500px"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;pdfobject-container&quot; data-target=&quot;https://drive.google.com/file/d/1EJ9ozQqEh6vm35fEdR3QRMbyv-yDTNJB/preview&quot; data-height=&quot;500px&quot;
      
    
    </summary>
    
    
      <category term="Report" scheme="https://yihang-li.github.io/categories/Report/"/>
    
    
      <category term="Report" scheme="https://yihang-li.github.io/tags/Report/"/>
    
      <category term="kernel" scheme="https://yihang-li.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>MDS6106Optimization-FinalProject</title>
    <link href="https://yihang-li.github.io/2021/01/09/MDS6106Optimization-FinalProject/"/>
    <id>https://yihang-li.github.io/2021/01/09/MDS6106Optimization-FinalProject/</id>
    <published>2021-01-08T21:16:42.000Z</published>
    <updated>2021-03-30T07:26:52.017Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The Report and the slides for my Optimization course’s final project</p><p>The code can be referenced at my <a href="https://github.com/Yihang-Li/MDS6106Project">Github Repository</a>, which is also my first team collaborate repo.</p></blockquote><div class="pdfobject-container" data-target="https://drive.google.com/file/d/1352y10oWzRa84c408Il909EVJkBoqm07/preview" data-height="500px"></div><div class="pdfobject-container" data-target="./pdf/Opt_Slides.pdf" data-height="500px"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;The Report and the slides for my Optimization course’s final project&lt;/p&gt;
&lt;p&gt;The code can be referenced at my &lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="Report" scheme="https://yihang-li.github.io/categories/Report/"/>
    
    
      <category term="Report" scheme="https://yihang-li.github.io/tags/Report/"/>
    
      <category term="Optimization" scheme="https://yihang-li.github.io/tags/Optimization/"/>
    
      <category term="Slides" scheme="https://yihang-li.github.io/tags/Slides/"/>
    
  </entry>
  
  <entry>
    <title>文献翻译-《Random Features for Large Scale Kernel Machines》</title>
    <link href="https://yihang-li.github.io/2021/01/08/%E6%96%87%E7%8C%AE%E7%BF%BB%E8%AF%91-%E3%80%8ARandom%20Features%20for%20Large%20Scale%20Kernel%20Machines%E3%80%8B/"/>
    <id>https://yihang-li.github.io/2021/01/08/%E6%96%87%E7%8C%AE%E7%BF%BB%E8%AF%91-%E3%80%8ARandom%20Features%20for%20Large%20Scale%20Kernel%20Machines%E3%80%8B/</id>
    <published>2021-01-08T03:23:52.000Z</published>
    <updated>2021-01-09T08:49:53.443Z</updated>
    
    <content type="html"><![CDATA[<div class="pdfobject-container" data-target="https://drive.google.com/file/d/17x-pyatNiu4QVd6XUqkTKWDtT6tXPPys/preview" data-height="500px"></div><!-- <iframe src="https://drive.google.com/file/d/17x-pyatNiu4QVd6XUqkTKWDtT6tXPPys/preview" width="640" height="480"></iframe> -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;pdfobject-container&quot; data-target=&quot;https://drive.google.com/file/d/17x-pyatNiu4QVd6XUqkTKWDtT6tXPPys/preview&quot; data-height=&quot;500px&quot;
      
    
    </summary>
    
    
      <category term="文献翻译" scheme="https://yihang-li.github.io/categories/%E6%96%87%E7%8C%AE%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="Kernel" scheme="https://yihang-li.github.io/tags/Kernel/"/>
    
      <category term="RFF" scheme="https://yihang-li.github.io/tags/RFF/"/>
    
  </entry>
  
  <entry>
    <title>Summary: Recent Advances and Trends in Large-Scale Kernel Methods</title>
    <link href="https://yihang-li.github.io/2020/02/24/Summary-Recent-Advances-and-Trends-in-Large-Scale-Kernel-Methods/"/>
    <id>https://yihang-li.github.io/2020/02/24/Summary-Recent-Advances-and-Trends-in-Large-Scale-Kernel-Methods/</id>
    <published>2020-02-24T07:54:58.000Z</published>
    <updated>2021-03-30T07:13:19.487Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jstage.jst.go.jp/article/transinf/E92.D/7/E92.D_7_1338/_pdf/-char/ja">RAandTinLSKM</a></p><h3 id="摘要部分"><a href="#摘要部分" class="headerlink" title="摘要部分"></a>摘要部分</h3><ol><li><p>核方法优势：通过使用核技巧可以把线性模型直接拓展到非线性应用场景</p></li><li><p>然鹅， 核方法的naive使用的计算复杂度是很高的，scales cubically w.r.t. 训练样本的数量</p><blockquote><p><span style='color:red'>表示不赞同，我现有层面的知识恰恰是能避免高维计算</span> <span style="color:green">(或许是不同的角度？)</span></p></blockquote></li><li><p>这篇文章回归了最近的处理大规模数据的核方法</p></li></ol><hr><a id="more"></a><h3 id="引言部分"><a href="#引言部分" class="headerlink" title="引言部分"></a>引言部分</h3><ol><li>核方法的关键：核函数——使得计算复杂度独立于特征空间的维数</li><li><em>Vapnik</em> 的重大工作使得很多线性的监督和非监督学习算法能够应用核方法（<span style="color:blue">Kernelized</span>)。包括岭回归、感知机、费希尔判别分析、主成分分析、K均值聚类和独立成分分析。</li><li>这篇文章的目的：回顾各种加速核方法的技巧</li><li>这篇文章的布局：<ul><li><em>Sect. 2</em> : 复习核方法的基础思想，回顾最近大数据核方法的进展，一个计算瓶颈是核矩阵K的计算</li><li><em>Sect. 3</em> : 回顾核矩阵能怎样被低秩矩阵逼近（考虑incomplete Cholesky decomposition、Lanczos approximation、Nystrom method and Gaussian transform）</li><li><em>Sect. 4</em> : 回顾监督核方法。回归部分：怎样用低秩逼近方法来加速相应核算法诸如RR、PLS、GP。分类部分：用cutting-plane或者dual coordinate descent 方法解决支持向量算法中的优化问题。</li><li>Sect. 5 : 关注非监督方法。怎样用拉普拉斯特征映射有效降低稀疏数据的维数，应用到谱聚类算法中</li><li>Sect. 6 : 面对structured 数据，怎样有效计算核函数。怎样从多个kernel构造出一个kernel。</li><li>Sect. 7 : 总结。</li></ul></li></ol><hr><hr><h3 id="Sect-2-核方法基础"><a href="#Sect-2-核方法基础" class="headerlink" title="Sect. 2 核方法基础"></a>Sect. 2 核方法基础</h3><p>考虑线性参数模型：</p><p>$f(\mathbf{x};\mathbf{w}) \equiv &lt;\mathbf{w},\mathbf{x}&gt; \tag{1}$</p><p>其中，$\mathbf{x} \in \mathcal{R^d}$是输入变量， $\mathbf{w} \in \mathcal{R^d}$是参数向量，$&lt;\dot{},\dot{}&gt;$表示内积。</p><p>给定训练数据$\{(\mathbf{x}_i,y_i)|\mathbf{x_i}\in \mathcal{R^d}, y_i \in \mathcal{R}\}_{i=1}^{\mathcal{l}}$, 为了确定参数$\mathbf{w}$，需要最小化经验风险项和正则项的线性和：</p><p>$J(\mathbf{w}) \equiv R_{emp}(\mathbf{w})+\lambda \Omega(\mathbf{w})$, 其中 $\lambda &gt; 0$ 为正则化参数。</p><p>以岭回归为例，使用平方损失函数来度量经验风险，$L_2$范数作为正则项：</p><blockquote><script type="math/tex; mode=display">R_{emp}(\mathbf{w}) \equiv \sum_{i=1}^{\mathcal{l}}(y_i-f(\mathbf{x_i};\mathbf{w}))^2 \tag{2}</script><script type="math/tex; mode=display">\Omega(\mathbf{w}) \equiv || \mathbf{w}||_{2}^{2} \tag{3}</script></blockquote><p>输入样本构成的数据矩阵记作：<script type="math/tex">\mathbf{X} = (\mathbf{x_1}|\mathbf{x_2}|...|\mathbf{x_\mathcal{l}})</script>，则岭回归的解析解为：</p><blockquote><script type="math/tex; mode=display">\widehat{\mathbf{w}} = (\mathbf{X}^T\mathbf{X}+\lambda\mathbf{I})^{-1}\mathbf{X}^T\mathbf{y} \tag{4}</script></blockquote><p>(4) 表明岭回归求解的计算复杂度为$O(d^3)$，依赖于输入空间的维数。</p><hr><blockquote><p>假设参数$\mathbf{w}$可以写成训练样本的线性组合：</p><script type="math/tex; mode=display">\mathbf{w} \equiv \sum_{i=1}^{\mathcal{l}}\alpha_i\mathbf{x_i} = \mathbf{X}\mathbf{\alpha} \tag{5}</script></blockquote><p>则 Eq. (1) 可以表示成：<script type="math/tex">f(\mathbf{x};\mathbf{\alpha}) \equiv \sum_{i=1}^{\mathcal{l}}\alpha_i<\mathbf{x}_i,\mathbf{x}></script></p><p>从而定义 <em>核函数</em> 为：<script type="math/tex">k(\mathbf{x},\mathbf{x'}) \equiv <\mathbf{x}, \mathbf{x'}></script>. </p><p>进一步参数模型可以表示为：</p><blockquote><script type="math/tex; mode=display">f(\mathbf{x}) = \sum_{i=1}^{\mathcal{l}}\alpha_ik(\mathbf{x}_i,\mathbf{x}) \tag{6}</script></blockquote><p>基于核化（kernelized）的模型，岭回归的目标函数可以重写为：<script type="math/tex">J(\alpha) = ||\mathbf{y}-\mathbf{K}\mathbf{\alpha}||^2+\lambda\mathbf{\alpha}^T\mathbf{K}\mathbf{\alpha}</script>，其中$\mathbf{K}$是$\mathcal{l} \times\mathcal{l}$的核矩阵（定义为：$K_{i,j} \equiv k(\mathbf{x}_i, \mathbf{x}_j)$）. 可解得：</p><blockquote><script type="math/tex; mode=display">\widehat{\mathbf{\alpha}} = (\mathbf{K} + \lambda\mathbf{I})^{-1}\mathbf{y} \tag{7}</script></blockquote><p>(7) 表明核岭回归的计算复杂度为$O（d\mathcal{l}^3)$，其中$d$来自于计算核函数的值，$\mathcal{l}^3$来自于计算核矩阵的逆。</p><p>因此，现在计算复杂度主要由训练样本的数量决定。</p><p>以上的形式是基于（5）这一线性假设，由<em>representer theorem</em>可以保证其正确性。</p><hr><p>为了说明核形式的优越性，考虑变换 <script type="math/tex">\Phi: \mathcal{R}^d \rightarrow \mathcal{R}^{d'}</script>. 我们假设 $d’ \gg d$ 而且通过变换后的样本$\{\Phi(x_i)\}_{i=1}^{\mathcal{l}}$来学习模型.</p><p>在原始形式（4）中， 因为$d’$很大，求解可能会比较棘手；而在核形式（7）中，输入样本仅仅在核函数的值的计算中处理：$k(\mathbf{x},\mathbf{x’})\equiv &lt;\Phi(\mathbf{x}), \Phi({\mathbf{x’}})&gt;$。</p><p>记 $t$ 为计算核函数值的复杂度，则计算解的复杂度为$O(t\mathcal{l}^3)$，不依赖于 $d’$。因此核形式可以让我们在$d’$比较大的时候更有效地计算解。</p><p>——这样的计算技巧称为核技巧</p><p>反之，如果存在对应于内积$&lt;\Phi(\mathbf{x}), \Phi({\mathbf{x’}})&gt;$的核函数，则用核形式会很有帮助。而这里的内积的存在性是有保证的，只需要核函数是半正定的（这样的核函数称为Mercer核或者再生核）。</p><hr><p>有很多核函数的计算复杂度都是独立于$d’$的：</p><blockquote><p>多项式核：$k(\mathbf{x},\mathbf{x’})=(&lt;\mathbf{x},\mathbf{x’}&gt;+1)^c$</p><p>高斯核：$k(\mathbf{x},\mathbf{x’})=e^{-||\mathbf{x}-\mathbf{x’}||^2/\sigma^2}$</p></blockquote><hr><p>然而，当训练样本很大的时候，核方法的计算复杂度仍然很高。</p><hr><hr><h3 id="Sect-4-监督方法"><a href="#Sect-4-监督方法" class="headerlink" title="Sect. 4 监督方法"></a>Sect. 4 监督方法</h3><h4 id="4-1-回归"><a href="#4-1-回归" class="headerlink" title="4.1 回归"></a>4.1 回归</h4><h5 id="4-1-1-核岭回归"><a href="#4-1-1-核岭回归" class="headerlink" title="4.1.1 核岭回归"></a>4.1.1 核岭回归</h5><p>从（7）知道，解KRR即相当于求解线性方程：<script type="math/tex">(\mathbf{K} + \lambda\mathbf{I}_{\mathcal{l}})\mathbf{\alpha} = \mathbf{y}</script>，</p><blockquote><p>通常的方法：Cholesky factorization $O(\mathcal{l}^3)$<br>若使用 CG 方法（共轭梯度法），$O(r\mathcal{l}^2)$ ，这里 $r$ 是CG迭代次数<br>若核函数是高斯核，CG方法的计算复杂度会降至 $O(\mathcal(l))$</p><p>可使用 LOOCV 来决定正则化参数$\lambda$，在KRR中，LOOCV score 的闭形式是：$g_{LOO}(\lambda)=||\mathbf{H}^{-1}(\mathbf{y}-\mathbf{K}\mathbf{\alpha})||^2$，这里$\mathbf{H} \equiv \mathbf{I}_N-diag(\mathbf{K}(\mathbf{K}+\lambda\mathbf{I}_{\mathcal{l}}^{-1}))$。然而，这里计算设计求逆 -&gt; $O(\mathcal{l}^3)$。</p></blockquote><h5 id="4-1-2-偏最小二乘"><a href="#4-1-2-偏最小二乘" class="headerlink" title="4.1.2 偏最小二乘"></a>4.1.2 偏最小二乘</h5><h5 id="4-1-3-Lasso"><a href="#4-1-3-Lasso" class="headerlink" title="4.1.3 Lasso"></a>4.1.3 Lasso</h5><blockquote><p>LARS -&gt; 能对所有的 $\lambda$ 获得Lasso解；但是对单个的 $\lambda$ ，简单的坐标下降法（coordinate descent）更快。</p><p>尽管Lasso是线性方法，它也可以被核化[38] [39], 一些学者也关注于怎样求解非线性形式的Lasso正则路径(regularization path)</p></blockquote><h5 id="4-1-4-高斯过程回归"><a href="#4-1-4-高斯过程回归" class="headerlink" title="4.1.4 高斯过程回归"></a>4.1.4 高斯过程回归</h5><h5 id="4-1-5-相关向量机（Relevance-Vector-Machines）"><a href="#4-1-5-相关向量机（Relevance-Vector-Machines）" class="headerlink" title="4.1.5 相关向量机（Relevance Vector Machines）"></a>4.1.5 相关向量机（Relevance Vector Machines）</h5><blockquote><p>4.1.4 &amp; 4.1.5 都是贝叶斯回归方法</p></blockquote><h5 id="4-1-6-支持向量回归"><a href="#4-1-6-支持向量回归" class="headerlink" title="4.1.6 支持向量回归"></a>4.1.6 支持向量回归</h5><p>SVR问题可形式化为最小化如下目标函数：</p><blockquote><script type="math/tex; mode=display">J_{SVR}(\mathbf{w})=\frac{C}{\mathcal{l}}\sum_{i=1}^{\mathcal{l}}l_{\epsilon}(y_i-<\mathbf{x}_i, \mathbf{w}>+\frac{1}{2}||\mathbf{w}||_2^2) \tag{17}</script></blockquote><p>这里  $l_{\epsilon}$ 称为 $\epsilon-insensitive$ 损失函数：<script type="math/tex">l_{\epsilon}(\eta) \equiv\left\{\begin{array}{ll}{0} & {\text { if }|\eta|<\epsilon} \\{|\eta|-\epsilon} & {\text { otherwise }}\end{array}\right.</script></p><p>常规解法是求解二次规划问题获得（17）的对偶形式，但是SVR可以有效地用4.2.1中的方法求解。</p><h4 id="4-2-分类"><a href="#4-2-分类" class="headerlink" title="4.2 分类"></a>4.2 分类</h4><h5 id="4-2-1-Cutting-Plane-Algorithm"><a href="#4-2-1-Cutting-Plane-Algorithm" class="headerlink" title="4.2.1 Cutting Plane Algorithm"></a>4.2.1 Cutting Plane Algorithm</h5><h5 id="4-2-2-Dual-Coordinate-Descent-Algorithm"><a href="#4-2-2-Dual-Coordinate-Descent-Algorithm" class="headerlink" title="4.2.2 Dual Coordinate Descent Algorithm"></a>4.2.2 Dual Coordinate Descent Algorithm</h5><h3 id="Sect-7-总结"><a href="#Sect-7-总结" class="headerlink" title="Sect. 7 总结"></a>Sect. 7 总结</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.jstage.jst.go.jp/article/transinf/E92.D/7/E92.D_7_1338/_pdf/-char/ja&quot;&gt;RAandTinLSKM&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;摘要部分&quot;&gt;&lt;a href=&quot;#摘要部分&quot; class=&quot;headerlink&quot; title=&quot;摘要部分&quot;&gt;&lt;/a&gt;摘要部分&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;核方法优势：通过使用核技巧可以把线性模型直接拓展到非线性应用场景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然鹅， 核方法的naive使用的计算复杂度是很高的，scales cubically w.r.t. 训练样本的数量&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span style=&#39;color:red&#39;&gt;表示不赞同，我现有层面的知识恰恰是能避免高维计算&lt;/span&gt; &lt;span style=&quot;color:green&quot;&gt;(或许是不同的角度？)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这篇文章回归了最近的处理大规模数据的核方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="Notes" scheme="https://yihang-li.github.io/categories/Notes/"/>
    
    
      <category term="Kernel Methods" scheme="https://yihang-li.github.io/tags/Kernel-Methods/"/>
    
      <category term="summary" scheme="https://yihang-li.github.io/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>Hilbert Space: Midterm Review</title>
    <link href="https://yihang-li.github.io/2020/02/16/Hilbert-Space-Midterm-Review/"/>
    <id>https://yihang-li.github.io/2020/02/16/Hilbert-Space-Midterm-Review/</id>
    <published>2020-02-16T05:00:13.000Z</published>
    <updated>2021-01-09T04:26:12.229Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h1><h2 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h2><ol><li><span style='color:blue'>Vector spaces</span>: Basis, linear independence</li><li><span style='color:blue'>Normed spaces</span>: Norm, convergence, equivalent norms</li><li><span style='color:blue'>Topology of normed spaces</span>: Open, closed, bounded, compact, and dense sets</li><li><span style='color:blue'>Banach spaces</span>: Cauchy sequences, completeness, convergent and absolutely convergent series</li><li><span style='color:blue'>Linear mappings</span>: Continuity, boundedness, the norm of a linear mapping</li></ol><h2 id="Chapter-3"><a href="#Chapter-3" class="headerlink" title="Chapter 3"></a>Chapter 3</h2><ol><li><span style='color:blue'>Inner product spaces</span>: Inner product, norm, Schwarz’s Inequality, Parallelogram Law, orthogonality,  Pythagorean Formula, strong and weak convergence, Hilbert spaces, isomorphic Hilbert spaces</li><li><span style='color:blue'>Orthonomal systems</span>: Orthogonal and orthonormal systems, Gram-Schmidt orthonormalization process, Pythagorean Formula, Bessel’s equality and inequality, the best approximation, complete orthonormal sequences and equivalent conditions, Parseval’s Formula, separable Hilbert spaces</li><li><span style='color:blue'>Orthogonal Complements and Projections</span>: Orthogonal sets, orthogonal complement, the closest point property,  orthogonal decompositions, orthogonal projections</li><li><span style='color:blue'>Linear functionals</span>: The norm of a linear functional, the Riesz Representation Theorem</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Outline&quot;&gt;&lt;a href=&quot;#Outline&quot; class=&quot;headerlink&quot; title=&quot;Outline&quot;&gt;&lt;/a&gt;Outline&lt;/h1&gt;&lt;h2 id=&quot;Chapter-1&quot;&gt;&lt;a href=&quot;#Chapter-1&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="Notes" scheme="https://yihang-li.github.io/categories/Notes/"/>
    
    
      <category term="Hilbert Space" scheme="https://yihang-li.github.io/tags/Hilbert-Space/"/>
    
      <category term="Summary" scheme="https://yihang-li.github.io/tags/Summary/"/>
    
      <category term="Review" scheme="https://yihang-li.github.io/tags/Review/"/>
    
  </entry>
  
  <entry>
    <title>Summary of Using Python to Access Web Data</title>
    <link href="https://yihang-li.github.io/2020/02/14/Summary%20of%20Using%20Python%20to%20Access%20Web%20Data/"/>
    <id>https://yihang-li.github.io/2020/02/14/Summary%20of%20Using%20Python%20to%20Access%20Web%20Data/</id>
    <published>2020-02-14T02:21:12.000Z</published>
    <updated>2021-01-09T03:32:56.534Z</updated>
    
    <content type="html"><![CDATA[<p><strong>First of all, thanks Dr. Charles Russell Severance</strong></p><blockquote><p>Why I write this summary?</p><ul><li>gained certificate from last winter vacation(2019)</li><li>need to apply this knowledge for data access</li></ul></blockquote><p><img src="/assets/image-20200214105208294.png" alt="image-20200214105208294" style="zoom:80%;" /></p><a id="more"></a><p><a href="https://www.py4e.com/book">Book Link</a></p><h1 id="Chapter-11-Regular-expressions"><a href="#Chapter-11-Regular-expressions" class="headerlink" title="Chapter 11 Regular expressions"></a>Chapter 11 Regular expressions</h1><blockquote><p>Regular expressions (regex) are almost their own little programming language for searching and parsing strings.</p></blockquote><p>_For more detail on regex, see: <a href="https://en.wikipedia.org/wiki/Regular_expression">wiki</a>, <a href="https://docs.python.org/3.5/library/re.html">python docs</a>._</p><h2 id="Cheat-Sheet"><a href="#Cheat-Sheet" class="headerlink" title="Cheat Sheet"></a>Cheat Sheet</h2><div class="table-container"><table><thead><tr><th style="text-align:center">symbol</th><th style="text-align:center">function</th></tr></thead><tbody><tr><td style="text-align:center"><span style="color:blue"> <strong>^</strong></span></td><td style="text-align:center">Matches the beginning of a line</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>$</strong></span></td><td style="text-align:center">Matches the end of the line</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>.</strong></span></td><td style="text-align:center">Matches any character (<strong>a wildcard</strong>)</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>\s</strong></span></td><td style="text-align:center">Matches whitespace</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>\S</strong></span></td><td style="text-align:center">Matches any non-whitespace character</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>?</strong></span></td><td style="text-align:center">Repeats a character zero or one time</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>??</strong></span></td><td style="text-align:center">Repeats a character zero of one time (<strong>non-greedy</strong>)</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>*</strong></span></td><td style="text-align:center">Repeats a character zero or more times</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>*?</strong></span></td><td style="text-align:center">Repeats a character zero or more times (<strong>non-greedy</strong>)</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>+</strong></span></td><td style="text-align:center">Repeats a character one or more times</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>+?</strong></span></td><td style="text-align:center">Repeats a character one or more times (<strong>non-greedy</strong>)</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>[aeiou]</strong></span></td><td style="text-align:center">Matches a single character in the listed set</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>[\^XYZ]</strong></span></td><td style="text-align:center">Matches a single character not in the listed set</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>[a-z0-9]</strong></span></td><td style="text-align:center">The set of  characters can include a range</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>(</strong></span></td><td style="text-align:center">Indicates where string extraction is to start</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>)</strong></span></td><td style="text-align:center">Indicates where string extraction is to end</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>\b</strong></span></td><td style="text-align:center">Matches the empty string only at the start of end of word</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>\B</strong></span></td><td style="text-align:center">Matches the empty string not at the start or end of a word</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>\d</strong></span></td><td style="text-align:center">Matches any decimal digit (equivalent to [0-9])</td></tr><tr><td style="text-align:center"><span style='color:blue'><strong>\D</strong></span></td><td style="text-align:center">Matches any non-digit character (equivalent to [\^0-9])</td></tr></tbody></table></div><p>_<strong>Note:</strong>_</p><blockquote><ol><li>symbol with repeat function applies to the immediately preceding character(s)</li><li>greedy matching: the repeat characters (  <span style='color:blue'><strong>*</strong></span>  and <span style='color:blue'><strong>+</strong></span> ) push outward in both directions to match the largest possible string</li><li>non-greedy doesn’t mean that the regex will try to find the shortest substring by varying the start index. It just means that if there’s a substring which starts at index 0 and matches the regex, the engine will stop as soon as possible </li><li>escape character: by prefixing with a backslash. i.e. \$ indicate dollar sign instead of the wildcard.</li></ol></blockquote><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Search for lines that start with From and have an at sign</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">hand = <span class="built_in">open</span>(<span class="string">&#x27;mbox-short.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> hand:</span><br><span class="line">    line = line.rstrip()</span><br><span class="line">    <span class="keyword">if</span> re.search(<span class="string">&#x27;^From:.+@&#x27;</span>, line):</span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure><p>The search string <strong>^From:.+@</strong> will successfully match lines that start with “<strong>From:</strong>“, followed by one or more characters (<strong>.+</strong>), followed by an at-sign. So this will match the following line:<br><strong>From: stephen.marquard@uct.ac.za</strong></p><h3 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = <span class="string">&quot;We just received $10.00 for cookies.&quot;</span></span><br><span class="line">y = re.findall(<span class="string">&#x27;\$[0-9.]+&#x27;</span>, x)</span><br></pre></td></tr></table></figure><p>Since we prefix the dollar sign with a backslash, it actually matches the dollar sign in the input string instead of matching the “end of line”, and the rest of the regular expression matches one or more digits or the period character.</p><p>Note: inside square brackets, characters are not “special”. So, when we say <strong>[0-9.]</strong>, it really means digits or a period . Outside of square brackets, a period is the “wildcard” character and matches any character. Inside square brackets, the period is a period.</p><hr><h1 id="Chapter-12-Networked-Programs"><a href="#Chapter-12-Networked-Programs" class="headerlink" title="Chapter 12 Networked Programs"></a>Chapter 12 Networked Programs</h1><h2 id="12-1-Hypertext-Transfer-Protocol-HTTP"><a href="#12-1-Hypertext-Transfer-Protocol-HTTP" class="headerlink" title="12.1 Hypertext Transfer Protocol - HTTP"></a>12.1 Hypertext Transfer Protocol - HTTP</h2><blockquote><p><strong>Socket/TCP Connections</strong><br>A network connection between two applications where the applications can send and receive data in either direction.</p><p><strong>TCP Port Numbers</strong><br>A number that generally indicates which application you are contacting when you make a socket connection to a server. As an example, web traffic usually uses port 80 while email traffic uses port 25.</p><p><strong>Protocol</strong><br>A protocol is a set of precise rules that all parties follow so we can predict each other’s behavior. In a sense the two applications at either end of the socket are doing a dance and making sure not to step on each other’s toes.</p></blockquote><p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616.txt">HyperText Transfer Protocol</a>, a long and complex 176-page document with a lot of detail. If you find it interesting, feel free to read it all. But if you take a look around page 36 of RFC2616 you will find the syntax for the GET request. </p><h2 id="12-2-The-world’s-simplest-web-browser"><a href="#12-2-The-world’s-simplest-web-browser" class="headerlink" title="12.2 The world’s simplest web browser"></a>12.2 The world’s simplest web browser</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code: http://www.py4e.com/code3/socket1.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">mysock.connect((<span class="string">&#x27;data.pr4e.org&#x27;</span>, <span class="number">80</span>))</span><br><span class="line">cmd = <span class="string">&#x27;GET http://data.pr4e.org/romeo.txt HTTP/1.0\r\n\r\n&#x27;</span>.encode()</span><br><span class="line">mysock.send(cmd)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = mysock.recv(<span class="number">512</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(data) &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(data.decode(), end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">mysock.close()</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200214180630075.png" alt="image-20200214180630075" style="zoom:80%;" /></p><p>Output:</p><blockquote><p>HTTP/1.1 200 OK<br>Date: Fri, 14 Feb 2020 23:05:30 GMT<br>Server: Apache/2.4.18 (Ubuntu)<br>Last-Modified: Sat, 13 May 2017 11:22:22 GMT<br>ETag: “a7-54f6609245537”<br>Accept-Ranges: bytes<br>Content-Length: 167<br>Cache-Control: max-age=0, no-cache, no-store, must-revalidate<br>Pragma: no-cache<br>Expires: Wed, 11 Jan 1984 05:00:00 GMT<br>Connection: close<br>Content-Type: text/plain</p><p>But soft what light through yonder window breaks<br>It is the east and Juliet is the sun<br>Arise fair sun and kill the envious moon<br>Who is already sick and pale with grief</p></blockquote><h2 id="12-3-Retrieving-an-image-over-HTTP"><a href="#12-3-Retrieving-an-image-over-HTTP" class="headerlink" title="12.3 Retrieving an image over HTTP"></a>12.3 Retrieving an image over HTTP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code: http://www.py4e.com/code3/urljpeg.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">&#x27;data.pr4e.org&#x27;</span></span><br><span class="line">PORT = <span class="number">80</span></span><br><span class="line">mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">mysock.connect((HOST, PORT))</span><br><span class="line">mysock.sendall(<span class="string">b&#x27;GET http://data.pr4e.org/cover3.jpg HTTP/1.0\r\n\r\n&#x27;</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line">picture = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = mysock.recv(<span class="number">5120</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">len</span>(data) &lt; <span class="number">1</span>): <span class="keyword">break</span></span><br><span class="line">    time.sleep(<span class="number">0.25</span>)</span><br><span class="line">    count = count + <span class="built_in">len</span>(data)</span><br><span class="line">    print(<span class="built_in">len</span>(data), count)</span><br><span class="line">    picture = picture + data</span><br><span class="line"></span><br><span class="line">mysock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Look for the end of the header (2 CRLF)</span></span><br><span class="line">pos = picture.find(<span class="string">b&#x27;\r\n\r\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;Header length&#x27;</span>, pos)</span><br><span class="line">print(picture[:pos].decode())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Skip past the header and save the picture data</span></span><br><span class="line">picture = picture[pos+<span class="number">4</span>:]</span><br><span class="line">fhand = <span class="built_in">open</span>(<span class="string">&#x27;stuff.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">fhand.write(picture)</span><br><span class="line">fhand.close()</span><br></pre></td></tr></table></figure><p>Output:</p><blockquote><p>1408 1408<br>5120 6528<br>5120 11648<br>…… ……<br>5120 221568<br>3920 230608<br>Header length 394<br>HTTP/1.1 200 OK<br>Date: Fri, 14 Feb 2020 23:21:44 GMT<br>Server: Apache/2.4.18 (Ubuntu)<br>Last-Modified: Mon, 15 May 2017 12:27:40 GMT<br>ETag: “38342-54f8f2e5b6277”<br>Accept-Ranges: bytes<br>Content-Length: 230210<br>Vary: Accept-Encoding<br>Cache-Control: max-age=0, no-cache, no-store, must-revalidate<br>Pragma: no-cache<br>Expires: Wed, 11 Jan 1984 05:00:00 GMT<br>Connection: close<br>Content-Type: image/jpeg</p></blockquote><p>There is a buffer between the server making <code>send()</code> requests and our application making <code>recv()</code> requests. When we run the program with the delay in place, at some point the server might fill up the buffer in the socket and be forced to pause until our program starts to empty the buffer.<br>The pausing of either the sending application or the receiving application is called “<strong>flow control</strong>“.</p><h2 id="12-4-Retrieving-web-pages-with-urllib"><a href="#12-4-Retrieving-web-pages-with-urllib" class="headerlink" title="12.4 Retrieving web pages with urllib"></a>12.4 Retrieving web pages with urllib</h2><blockquote><p><strong>urllib</strong>: does all the socket work for us and makes web pages look like a file.</p></blockquote><p>Using <code>urllib</code>, you can treat a web page much like a file. You simply indicate which web page you would like to retrieve and <code>urllib</code> handles all of the HTTP protocol and header details.</p><p>The equivalent code to read the <code>romeo.txt</code> file from the web using <code>urllib</code> is as follows:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code: http://www.py4e.com/code3/urllib1.py</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">fhand = urllib.request.urlopen(<span class="string">&#x27;http://data.pr4e.org/romeo.txt&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> fhand:</span><br><span class="line">    print(line.decode().strip())</span><br></pre></td></tr></table></figure><p>When the program runs, we only see the output of the contents of the file. The headers are still sent, but the <code>urllib</code> code consumes the headers and only returns the data to us.</p><p>Output:</p><blockquote><p>But soft what light through yonder window breaks<br>It is the east and Juliet is the sun<br>Arise fair sun and kill the envious moon<br>Who is already sick and pale with grief</p></blockquote><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>retrieve the data for <code>romeo.txt</code> and compute the frequency of each word in the file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Code: http:&#x2F;&#x2F;www.py4e.com&#x2F;code3&#x2F;urlwords.py</span><br><span class="line">import urllib.request, urllib.parse, urllib.error</span><br><span class="line"></span><br><span class="line">fhand &#x3D; urllib.request.urlopen(&#39;http:&#x2F;&#x2F;data.pr4e.org&#x2F;romeo.txt&#39;)</span><br><span class="line"></span><br><span class="line">counts &#x3D; dict()</span><br><span class="line">for line in fhand:</span><br><span class="line">    words &#x3D; line.decode().split()</span><br><span class="line">    for word in words:</span><br><span class="line">        counts[word] &#x3D; counts.get(word, 0) + 1</span><br><span class="line">print(counts)</span><br></pre></td></tr></table></figure><p>Output:</p><blockquote><p>{‘But’: 1, ‘soft’: 1, ‘what’: 1, ‘light’: 1, ‘through’: 1, ‘yonder’: 1, ‘window’: 1, ‘breaks’: 1, ‘It’: 1, ‘is’: 3, ‘the’: 3, ‘east’: 1, ‘and’: 3, ‘Juliet’: 1, ‘sun’: 2, ‘Arise’: 1, ‘fair’: 1, ‘kill’: 1, ‘envious’: 1, ‘moon’: 1, ‘Who’: 1, ‘already’: 1, ‘sick’: 1, ‘pale’: 1, ‘with’: 1, ‘grief’: 1}</p></blockquote><h2 id="12-5-Reading-binary-files-using-urllib"><a href="#12-5-Reading-binary-files-using-urllib" class="headerlink" title="12.5 Reading binary files using urllib"></a>12.5 Reading binary files using urllib</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Code: http://www.py4e.com/code3/curl2.py</span></span><br><span class="line"><span class="keyword">import</span> urllib.request, urllib.parse, urllib.error</span><br><span class="line"></span><br><span class="line">img = urllib.request.urlopen(<span class="string">&#x27;http://data.pr4e.org/cover3.jpg&#x27;</span>)</span><br><span class="line">fhand = <span class="built_in">open</span>(<span class="string">&#x27;cover3.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">size = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    info = img.read(<span class="number">100000</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(info) &lt; <span class="number">1</span>: <span class="keyword">break</span></span><br><span class="line">    size += <span class="built_in">len</span>(info)</span><br><span class="line">    fhand.write(info)</span><br><span class="line">print(size, <span class="string">&#x27;characters copied.&#x27;</span>)</span><br><span class="line">fhand.close()</span><br></pre></td></tr></table></figure><blockquote><p>read only 100,000 characters at a time and then write those characters to the cover.jpg file before retrieving the next 100,000 characters of data from the web.</p></blockquote><h2 id="12-6-Parsing-HTML-and-scraping-the-web"><a href="#12-6-Parsing-HTML-and-scraping-the-web" class="headerlink" title="12.6 Parsing HTML and scraping the web"></a>12.6 Parsing HTML and scraping the web</h2><blockquote><p>One of the common uses of the <code>urllib</code> capability in Python is to <em>scrape</em> the web. Web scraping is when we write a program that pretends to be a web browser and retrieves pages, then examines the data in those pages looking for patterns.</p><p>As an example, a search engine such as Google will look at the source of one web page and extract the links to other pages and retrieve those pages, extracting links, and so on. Using this technique, Google <em>spiders</em> its way through nearly all of the pages on the web.</p><p>Google also uses the frequency of links from pages it finds to a particular page as one measure of how “important” a page is and how high the page should appear in its search results.</p></blockquote><h2 id="12-7-Parsing-HTML-using-regular-expressions"><a href="#12-7-Parsing-HTML-using-regular-expressions" class="headerlink" title="12.7 Parsing HTML using regular expressions"></a>12.7 Parsing HTML using regular expressions</h2><p>For the simple webpage:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>The First Page<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">If you like, you can switch to the</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.dr-chuck.com/page2.htm&quot;</span>&gt;</span></span><br><span class="line">Second Page<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>We can construct a well-formed regular expression to match and extract the link values from the above text as follows:</p><blockquote><p>href=”(<a href="http://.+?">http://.+?</a>)”</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code: http://www.py4e.com/code3/urlregex.py</span></span><br><span class="line"><span class="keyword">import</span> urllib.request, urllib.parse, urllib.error</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">url = <span class="built_in">input</span>(<span class="string">&#x27;Enter - &#x27;</span>)</span><br><span class="line">html = urllib.request.urlopen(url).read()</span><br><span class="line">links = re.findall(<span class="string">b&#x27;href=&quot;(http://.+?)&quot;&#x27;</span>, html)</span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> links:</span><br><span class="line">    print(link.decode())</span><br></pre></td></tr></table></figure><p>Output:</p><blockquote><p>Enter -  <a href="https://yihang-li.github.io/">https://yihang-li.github.io/</a><br><a href="http://yihang-li.github.io/">http://yihang-li.github.io/</a><br><a href="http://Yihang-Li.github.io/2020/02/14/Summary-of-UPtoAWD-Coursera/">http://Yihang-Li.github.io/2020/02/14/Summary-of-UPtoAWD-Coursera/</a><br><a href="http://Yihang-Li.github.io/2020/02/10/Summary-for-visualization-of-geospatial-data/">http://Yihang-Li.github.io/2020/02/10/Summary-for-visualization-of-geospatial-data/</a><br><a href="http://Yihang-Li.github.io/2020/02/08/Notes-of-Gaussian-Processes-for-Machine-Learning/">http://Yihang-Li.github.io/2020/02/08/Notes-of-Gaussian-Processes-for-Machine-Learning/</a><br><a href="http://Yihang-Li.github.io/2020/02/05/Hello-Echo/">http://Yihang-Li.github.io/2020/02/05/Hello-Echo/</a><br><a href="http://Yihang-Li.github.io/2020/02/05/hello-world/">http://Yihang-Li.github.io/2020/02/05/hello-world/</a></p></blockquote><h2 id="12-8-Parsing-HTML-using-BeautifulSoup"><a href="#12-8-Parsing-HTML-using-BeautifulSoup" class="headerlink" title="12.8 Parsing HTML using BeautifulSoup"></a>12.8 Parsing HTML using BeautifulSoup</h2><blockquote><p><strong>BeautifulSoup</strong> tolerates highly flawed HTML and still lets you easily extract the data you need. See <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/">docs</a>.</p></blockquote><p>We will use <code>urllib</code> to read the page and then use <code>BeautifulSoup</code> to extract the <code>href</code> attributes from the anchor (<code>a</code>) tags.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code: http://www.py4e.com/code3/urllinks.py</span></span><br><span class="line"><span class="keyword">import</span> urllib.request, urllib.parse, urllib.error</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore SSL certificate errors</span></span><br><span class="line">ctx = ssl.create_default_context()</span><br><span class="line">ctx.check_hostname = <span class="literal">False</span></span><br><span class="line">ctx.verify_mode = ssl.CERT_NONE</span><br><span class="line"></span><br><span class="line">url = <span class="built_in">input</span>(<span class="string">&#x27;Enter - &#x27;</span>)</span><br><span class="line">html = urllib.request.urlopen(url, context=ctx).read()</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve all of the anchor tags</span></span><br><span class="line">tags = soup(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">    print(tag.get(<span class="string">&#x27;href&#x27;</span>, <span class="literal">None</span>))</span><br></pre></td></tr></table></figure><p>The program prompts for a web address, then opens the web page, reads the data and passes the data to the BeautifulSoup parser, and then retrieves all of the anchor tags and prints out the <code>href</code> attribute for each tag.</p><p>You can use BeautifulSoup to pull out various parts of each tag as follows:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code: http://www.py4e.com/code3/urllink2.py</span></span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> ssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ignore SSL certificate errors</span></span><br><span class="line">ctx = ssl.create_default_context()</span><br><span class="line">ctx.check_hostname = <span class="literal">False</span></span><br><span class="line">ctx.verify_mode = ssl.CERT_NONE</span><br><span class="line"></span><br><span class="line">url = <span class="built_in">input</span>(<span class="string">&#x27;Enter - &#x27;</span>)</span><br><span class="line">html = urlopen(url, context=ctx).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># html.parser is the HTML parser included in the standard Python 3 library.</span></span><br><span class="line"><span class="comment"># information on other HTML parsers is here:</span></span><br><span class="line"><span class="comment"># http://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-a-parser</span></span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Retrieve all of the anchor tags</span></span><br><span class="line">tags = soup(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> tags:</span><br><span class="line">    <span class="comment"># Look at the parts of a tag</span></span><br><span class="line">    print(<span class="string">&#x27;TAG:&#x27;</span>, tag)</span><br><span class="line">    print(<span class="string">&#x27;URL:&#x27;</span>, tag.get(<span class="string">&#x27;href&#x27;</span>, <span class="literal">None</span>))</span><br><span class="line">    print(<span class="string">&#x27;Contents:&#x27;</span>, tag.contents[<span class="number">0</span>])</span><br><span class="line">    print(<span class="string">&#x27;Attrs:&#x27;</span>, tag.attrs)</span><br></pre></td></tr></table></figure><h2 id="12-9-Something-more"><a href="#12-9-Something-more" class="headerlink" title="12.9 Something more"></a>12.9 Something more</h2><blockquote><p><strong>Scrape</strong><br>When a program pretends to be a web browser and retrieves a web page, then looks at the web page content. Often programs are following the links in one page to find the next page so they can traverse a network of pages or a social network.</p><p><strong>Spider</strong><br>The act of a web search engine retrieving a page and then all the pages linked from a page and so on until they have nearly all of the pages on the Internet which they use to build their search index.</p><p><strong>ASCII</strong><br>American Standard Code for Information Interchange</p><p>Each character is represented by a number between 0 and 256 stored in 8 bits of memory(a byte of memory)</p><p>The <strong>ord()</strong> function tells us the numeric value of a simple ASCII character<br>(On the opposite, we can use <strong>chr()</strong>)</p><p>In Python3, all strings are unicode. When we read data from an external resource, we must decode it based on the character set so it is properly represented in Python3 as a string.</p></blockquote><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul><li>The TCP/IP gives us pipes/sockets between applications</li><li>We designed application protocols to make use of these pipes</li><li>HyperText Transfer Protocol (HTTP) is a simple yet powerful proctocol</li><li>Python has good support for sockets, HTTP, and HTML parsing</li></ul><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><h1 id="Chapter-13-Using-Web-Services"><a href="#Chapter-13-Using-Web-Services" class="headerlink" title="Chapter 13 Using Web Services"></a>Chapter 13 Using Web Services</h1><h2 id="13-1-eXtensible-Markup-Language-XML"><a href="#13-1-eXtensible-Markup-Language-XML" class="headerlink" title="13.1 eXtensible Markup Language - XML"></a>13.1 eXtensible Markup Language - XML</h2><p>XML looks similar to HTML but more structured. See a sample below:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Chuck<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">phone</span> <span class="attr">type</span>=<span class="string">&quot;intl&quot;</span>&gt;</span></span><br><span class="line">     +1 734 303 4456</span><br><span class="line">  <span class="tag">&lt;/<span class="name">phone</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">email</span> <span class="attr">hide</span>=<span class="string">&quot;yes&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Often it is helpful to think of an XML document as a tree structure where there is a top tag <code>person</code> and other tags such as <code>phone</code> are drawn as <em>children</em> of their parent nodes.</p><p><img src="/assets/image-20200214211642103.png" alt="image-20200214211642103" style="zoom:80%;" /></p><h2 id="13-2-Parsing-XML"><a href="#13-2-Parsing-XML" class="headerlink" title="13.2 Parsing XML"></a>13.2 Parsing XML</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code: http://www.py4e.com/code3/xml1.py</span></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;person&gt;</span></span><br><span class="line"><span class="string">  &lt;name&gt;Chuck&lt;/name&gt;</span></span><br><span class="line"><span class="string">  &lt;phone type=&quot;intl&quot;&gt;</span></span><br><span class="line"><span class="string">     +1 734 303 4456</span></span><br><span class="line"><span class="string">   &lt;/phone&gt;</span></span><br><span class="line"><span class="string">   &lt;email hide=&quot;yes&quot;/&gt;</span></span><br><span class="line"><span class="string">&lt;/person&gt;&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">tree = ET.fromstring(data)</span><br><span class="line">print(<span class="string">&#x27;Name:&#x27;</span>, tree.find(<span class="string">&#x27;name&#x27;</span>).text)</span><br><span class="line">print(<span class="string">&#x27;Attr:&#x27;</span>, tree.find(<span class="string">&#x27;email&#x27;</span>).get(<span class="string">&#x27;hide&#x27;</span>))</span><br></pre></td></tr></table></figure><p>Output:</p><blockquote><p>Name: Chuck<br>Attr: yes</p></blockquote><p>Calling <code>fromstring</code> converts the string representation of the XML into a “tree” of XML nodes. When the XML is in a tree, we have a series of methods we can call to extract portions of data from the XML.</p><p>The <code>find</code> function searches through the XML tree and retrieves a <em>node</em> that matches the specified tag. Each node can have some text, some attributes (like hide), and some “child” nodes. Each node can be the top of a tree of nodes.</p><h2 id="13-3-Looping-through-nodes"><a href="#13-3-Looping-through-nodes" class="headerlink" title="13.3 Looping through nodes"></a>13.3 Looping through nodes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code: http://www.py4e.com/code3/xml2.py</span></span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;stuff&gt;</span></span><br><span class="line"><span class="string">    &lt;users&gt;</span></span><br><span class="line"><span class="string">        &lt;user x=&quot;2&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;id&gt;001&lt;/id&gt;</span></span><br><span class="line"><span class="string">            &lt;name&gt;Chuck&lt;/name&gt;</span></span><br><span class="line"><span class="string">        &lt;/user&gt;</span></span><br><span class="line"><span class="string">        &lt;user x=&quot;7&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;id&gt;009&lt;/id&gt;</span></span><br><span class="line"><span class="string">            &lt;name&gt;Brent&lt;/name&gt;</span></span><br><span class="line"><span class="string">        &lt;/user&gt;</span></span><br><span class="line"><span class="string">    &lt;/users&gt;</span></span><br><span class="line"><span class="string">&lt;/stuff&gt;&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">stuff = ET.fromstring(<span class="built_in">input</span>)</span><br><span class="line">lst = stuff.findall(<span class="string">&#x27;users/user&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;User count:&#x27;</span>, <span class="built_in">len</span>(lst))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> lst:</span><br><span class="line">    print(<span class="string">&#x27;Name&#x27;</span>, item.find(<span class="string">&#x27;name&#x27;</span>).text)</span><br><span class="line">    print(<span class="string">&#x27;Id&#x27;</span>, item.find(<span class="string">&#x27;id&#x27;</span>).text)</span><br><span class="line">    print(<span class="string">&#x27;Attribute&#x27;</span>, item.get(<span class="string">&quot;x&quot;</span>))</span><br></pre></td></tr></table></figure><p>Output:</p><blockquote><p>User count: 2<br>Name Chuck<br>Id 001<br>Attribute 2<br>Name Brent<br>Id 009<br>Attribute 7</p></blockquote><p>Note:</p><blockquote><p>It is important to includes all parents level elements in the <strong>findall</strong> statement except for the top level element. Otherwise, Python will not find any desired nodes.</p></blockquote><h2 id="13-4-JavaScript-Object-Notation-JSON"><a href="#13-4-JavaScript-Object-Notation-JSON" class="headerlink" title="13.4 JavaScript Object Notation - JSON"></a>13.4 JavaScript Object Notation - JSON</h2><blockquote><p>The JSON format was inspired by the object and array format used in the JavaScript language. But since Python was invented before JavaScript, Python’s syntax for dictionaries and lists influenced the syntax of JSON. So the format of JSON is nearly identical to a combination of Python lists and dictionaries.</p></blockquote><p>Here is a JSON encoding that is roughly equivalent to the simple XML from above:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;Chuck&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;phone&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;intl&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;number&quot;</span> : <span class="string">&quot;+1 734 303 4456&quot;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">&quot;email&quot;</span> : &#123;</span><br><span class="line">     <span class="attr">&quot;hide&quot;</span> : <span class="string">&quot;yes&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>In XML, we can add attributes like “intl” to the “phone” tag.<br>In JSON, we simply have key-value pairs. Also the XML “person” tag is gone, replaced by a set of outer curly braces.</p><p>In general, JSON structures are simpler than XML because JSON has fewer capabilities than XML. But JSON has the advantage that it maps <em>directly</em> to some combination of dictionaries and lists. And since nearly all programming languages have something equivalent to Python’s dictionaries and lists, JSON is a very natural format to have two cooperating programs exchange data.</p><p>JSON is quickly becoming the format of choice for nearly all data exchange between applications because of its relative simplicity compared to XML.</p></blockquote><h2 id="13-5-Parsing-JSON"><a href="#13-5-Parsing-JSON" class="headerlink" title="13.5 Parsing JSON"></a>13.5 Parsing JSON</h2><blockquote><p>We construct our JSON by nesting dictionaries (objects) and lists as needed. In this example, we represent a list of users where each user is a set of key-value pairs (i.e., a dictionary). So we have a list of dictionaries.</p><p>In the following program, we use the built-in <em>json</em> library to parse the JSON and read through the data. Compare this closely to the equivalent XML data and code above. The JSON has less detail, so we must know in advance that we are getting a list and that the list is of users and each user is a set of key-value pairs. The JSON is more succinct (an advantage) but also is less self-describing (a disadvantage).</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Code: http://www.py4e.com/code3/json2.py</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">  &#123; &quot;id&quot; : &quot;001&quot;,</span></span><br><span class="line"><span class="string">    &quot;x&quot; : &quot;2&quot;,</span></span><br><span class="line"><span class="string">    &quot;name&quot; : &quot;Chuck&quot;</span></span><br><span class="line"><span class="string">  &#125; ,</span></span><br><span class="line"><span class="string">  &#123; &quot;id&quot; : &quot;009&quot;,</span></span><br><span class="line"><span class="string">    &quot;x&quot; : &quot;7&quot;,</span></span><br><span class="line"><span class="string">    &quot;name&quot; : &quot;Chuck&quot;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">]&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">info = json.loads(data)</span><br><span class="line">print(<span class="string">&#x27;User count:&#x27;</span>, <span class="built_in">len</span>(info))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line">    print(<span class="string">&#x27;Name&#x27;</span>, item[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line">    print(<span class="string">&#x27;Id&#x27;</span>, item[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">    print(<span class="string">&#x27;Attribute&#x27;</span>, item[<span class="string">&#x27;x&#x27;</span>])</span><br></pre></td></tr></table></figure><p>Output:</p><blockquote><p>User count: 2<br>Name Chuck<br>Id 001<br>Attribute 2<br>Name Chuck<br>Id 009<br>Attribute 7</p></blockquote><ul><li>we get from <em>json.loads()</em> is a Python list which we traverse with a <code>for</code> loop, and each item within that list is a Python dictionary.</li><li>In general, there is an industry trend away from XML and towards JSON for web services. </li><li>But XML is more self-descriptive than JSON and so there are some applications where XML retains an advantage. For example, most word processors store documents internally using XML rather than JSON.</li></ul><h2 id="13-6-Application-Programming-Interfaces-API"><a href="#13-6-Application-Programming-Interfaces-API" class="headerlink" title="13.6 Application Programming Interfaces - API"></a>13.6 Application Programming Interfaces - API</h2><blockquote><p><strong>API</strong><br>A contract between applications that defines the patterns of interaction between two application components</p><p><strong>SOA</strong><br>When we begin to build our programs where the functionality of our program includes access to services provided by other programs, we call the approach a <em>Service-Oriented Architecture</em> or SOA. (A non-SOA approach is where the application is a single standalone application which contains all of the code necessary to implement the application.)</p></blockquote><p>We see many examples of SOA when we use the web. We can go to a single web site and book air travel, hotels, and automobiles all from a single site. The data for hotels is not stored on the airline computers. Instead, the airline computers contact the services on the hotel computers and retrieve the hotel data and present it to the user. When the user agrees to make a hotel reservation using the airline site, the airline site uses another web service on the hotel systems to actually make the reservation. And when it comes time to charge your credit card for the whole transaction, still other computers become involved in the process.</p><p><img src="/assets/image-20200215104121294.png" alt="API_SOA" style="zoom:80%;" /></p><blockquote><p>When an application makes a set of services in its API available over the web, we call these <strong><em>web services</em></strong>.</p></blockquote><h2 id="13-7-Security-and-API-usage"><a href="#13-7-Security-and-API-usage" class="headerlink" title="13.7 Security and API usage"></a>13.7 Security and API usage</h2><blockquote><p>It is quite common that you need an API key to make use of a vendor’s API.<br>The general idea is that they want to know who is using their services and how much each user is using.</p><p>Sometimes once you get your API key, you simply include the key as part of POST data or perhaps as a parameter on the URL when calling the API.<br>Other times, the vendor wants increased assurance of the source of the requests and so they add expect you to send cryptographically signed messages using shared keys and secrets.</p><p> A very common technology that is used to sign requests over the Internet is called <a href="www.oauth.net"><em>OAuth</em></a>.</p></blockquote><h2 id="13-8-Application"><a href="#13-8-Application" class="headerlink" title="13.8 Application"></a>13.8 Application</h2><h3 id="13-8-1-Google-geocoding-web-service"><a href="#13-8-1-Google-geocoding-web-service" class="headerlink" title="13.8.1 Google geocoding web service"></a>13.8.1 Google geocoding web service</h3><blockquote><p><em>When you are using a free API like Google’s geocoding API, you need to be respectful in your use of these resources. If too many people abuse the service, Google might drop or significantly curtail its free service.</em></p></blockquote><p>Need API!</p><h3 id="13-8-2-Twitter"><a href="#13-8-2-Twitter" class="headerlink" title="13.8.2 Twitter"></a>13.8.2 Twitter</h3><blockquote><p>As the Twitter API became increasingly valuable, Twitter went from an open and public API to an API that required the use of OAuth signatures on each API request. </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;First of all, thanks Dr. Charles Russell Severance&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Why I write this summary?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gained certificate from last winter vacation(2019)&lt;/li&gt;
&lt;li&gt;need to apply this knowledge for data access&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/assets/image-20200214105208294.png&quot; alt=&quot;image-20200214105208294&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Notes" scheme="https://yihang-li.github.io/categories/Notes/"/>
    
    
      <category term="python" scheme="https://yihang-li.github.io/tags/python/"/>
    
      <category term="coursera" scheme="https://yihang-li.github.io/tags/coursera/"/>
    
      <category term="web" scheme="https://yihang-li.github.io/tags/web/"/>
    
      <category term="data access" scheme="https://yihang-li.github.io/tags/data-access/"/>
    
  </entry>
  
  <entry>
    <title>Summary for visualization of geospatial data</title>
    <link href="https://yihang-li.github.io/2020/02/10/Summary-for-visualization-of-geospatial-data/"/>
    <id>https://yihang-li.github.io/2020/02/10/Summary-for-visualization-of-geospatial-data/</id>
    <published>2020-02-10T06:04:01.000Z</published>
    <updated>2021-01-09T04:26:12.229Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Here we summarize the geospatial data visualization.</strong></p><p>The <code>Synthetic Power Grid Data Set</code>  will be used as an example. [<a href="https://wimnet.ee.columbia.edu/portfolio/synthetic-power-grids-data-sets/">Download here</a>]</p><p>Before all the things, let’s import some basic tools:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="1-Data-Preparation"><a href="#1-Data-Preparation" class="headerlink" title="1. Data Preparation"></a>1. Data Preparation</h2><h3 id="1-1-Import-Data"><a href="#1-1-Import-Data" class="headerlink" title="1.1 Import Data"></a>1.1 Import Data</h3><blockquote><p>Here, the <code>Location</code>( (Lon, Lat) pairs), <code>Demand</code> and <code>Supply</code> information are loaded by using <code>pandas.read_csv(&quot;path&quot;)</code>. </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bus_Location = pd.read_csv(<span class="string">&quot;Gen_WI_Bus_Locations.csv&quot;</span>)</span><br><span class="line">Demand_Values = pd.read_csv(<span class="string">&quot;Gen_WI_Demand_Values.csv&quot;</span>)</span><br><span class="line">Supply_Values = pd.read_csv(<span class="string">&quot;Gen_WI_Supply_Values.csv&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-2-Merge-Data"><a href="#1-2-Merge-Data" class="headerlink" title="1.2 Merge Data"></a>1.2 Merge Data</h3><blockquote><p>These 3 tables have the same column named <strong>_Bus Number_</strong> , we can use <code>reduce()</code> to merge them.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># first compile the list of dataframes we want to merge</span></span><br><span class="line">data_frames = [Bus_Location, Demand_Values, Supply_Values]</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">df_merged = reduce(<span class="keyword">lambda</span>  left,right: pd.merge(left,right,on=[<span class="string">&#x27;Bus Number&#x27;</span>], how=<span class="string">&#x27;outer&#x27;</span>), data_frames)</span><br><span class="line"><span class="comment">#Then call head() method, we can see the first five rows of our merged data</span></span><br><span class="line">df_merged.head()</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210151126713.png" alt="head" style="zoom:67%;" /></p><blockquote><p>Moreover, we can call <code>describe()</code> method to summarize our data.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_merged[[<span class="string">&#x27;Lon&#x27;</span>, <span class="string">&#x27;Lat&#x27;</span>, <span class="string">&#x27;Demand (MW)&#x27;</span>, <span class="string">&#x27;Supply (MW)&#x27;</span>]].describe()</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210151217027.png" alt="describe" style="zoom:67%;" /></p><hr><h2 id="2-Using-geopandas-to-visualize"><a href="#2-Using-geopandas-to-visualize" class="headerlink" title="2. Using geopandas to visualize"></a>2. Using geopandas to visualize</h2><blockquote><p>We can refer to <code>geopandas</code> docs <a href="https://geopandas.org/">Click here</a>.</p></blockquote><h3 id="2-1-Data-Structures"><a href="#2-1-Data-Structures" class="headerlink" title="2.1 Data Structures"></a>2.1 Data Structures</h3><blockquote><p>GeoPandas implements two main data structures, a <code>GeoSeries</code> and a <code>GeoDataFrame</code>. These are subclasses of pandas <code>Series</code> and <code>DataFrame</code>, respectively. Before visualization, we should convert our data into proper type.</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line">gdf = gpd.GeoDataFrame(df_merged, geometry = gpd.points_from_xy(df_merged.Lon, df_merged.Lat))</span><br><span class="line">gdf.head()</span><br><span class="line"><span class="comment">#And here call type(gdf):</span></span><br><span class="line"><span class="comment">#geopandas.geodataframe.GeoDataFrame</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210153603866.png" alt="gdfhead" style="zoom:65%;" /></p><h3 id="2-2-Coordinate-Reference-Systems"><a href="#2-2-Coordinate-Reference-Systems" class="headerlink" title="2.2 Coordinate Reference Systems"></a>2.2 Coordinate Reference Systems</h3><blockquote><p>CRS are important because the geometric shapes in a GeoSeries or GeoDataFrame object are simply a collection of coordinates in an arbitrary space. A CRS tells Python how those coordinates related to places on the Earth.</p><p>CRS are referred to using codes called <a href="https://en.wikipedia.org/wiki/PROJ.4">proj4 strings</a>. You can find the codes for most commonly used projections from <a href="http://spatialreference.org/">www.spatialreference.org</a>. Common projections can also be referred to by EPSG codes, so this same projection can also called using the proj4 string <code>&quot;+init=epsg:4326&quot;</code>.</p><p><em>geopandas</em> can accept lots of representations of CRS, including the proj4 string itself (<code>&quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&quot;</code>) or parameters broken out in a dictionary: <code>&#123;&#39;proj&#39;: &#39;latlong&#39;, &#39;ellps&#39;: &#39;WGS84&#39;, &#39;datum&#39;: &#39;WGS84&#39;, &#39;no_defs&#39;: True&#125;</code>). In addition, some functions will take EPSG codes directly.</p><p>For reference, a few very common projections and their proj4 strings:</p><ul><li>WGS84 Latitude/Longitude: <code>&quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs&quot;</code> or <code>&quot;+init=epsg:4326&quot;</code></li><li>UTM Zones (North): <code>&quot;+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs&quot;</code></li><li>UTM Zones (South): <code>&quot;+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs +south&quot;</code></li></ul><p><code>contextily</code>: context geo tiles in Python</p><blockquote><p><code>contextily</code> is a small Python 3 package to retrieve and write to disk tile maps from the internet into geospatial raster files. Bounding boxes can be passed in both WGS84 (<code>EPSG:4326</code>) and Spheric Mercator (<code>EPSG:3857</code>). See <a href="https://github.com/darribas/contextily">here</a> for usage.</p></blockquote></blockquote><hr><p><strong>Let’s just dive into code</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextily <span class="keyword">as</span> ctx</span><br><span class="line">gdf.crs = &#123;<span class="string">&#x27;init&#x27;</span>: <span class="string">&#x27;epsg:4326&#x27;</span>, <span class="string">&#x27;no_defs&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">gdf = gdf.to_crs(epsg=<span class="number">3857</span>)</span><br><span class="line">ax = gdf.plot(figsize=(<span class="number">10</span>, <span class="number">10</span>), alpha=<span class="number">0.5</span>, edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">ctx.add_basemap(ax)</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210161956076.png" alt="first" style="zoom:67%;" /></p><h3 id="2-3-Mapping-attributes-into-it"><a href="#2-3-Mapping-attributes-into-it" class="headerlink" title="2.3 Mapping attributes into it"></a>2.3 Mapping attributes into it</h3><blockquote><p>Here we map the <code>Demand</code> values into the map, and try to set some parameters</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax = gdf.plot(figsize=(<span class="number">10</span>, <span class="number">10</span>), alpha=<span class="number">0.5</span>, edgecolor=<span class="string">&#x27;w&#x27;</span>, column = <span class="string">&quot;Demand (MW)&quot;</span>, legend = <span class="literal">True</span>, </span><br><span class="line">              legend_kwds=&#123;<span class="string">&#x27;label&#x27;</span>: <span class="string">&quot;Demand (MW)&quot;</span>,<span class="string">&#x27;orientation&#x27;</span>: <span class="string">&quot;vertical&quot;</span>&#125;) <span class="comment">#horizontal</span></span><br><span class="line">ctx.add_basemap(ax, url=ctx.providers.Stamen.TonerLite)</span><br><span class="line">ax.set_axis_off()</span><br><span class="line">plt.savefig(<span class="string">&#x27;Demand(MW)&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210162505599.png" alt="Second" style="zoom:67%;" /></p><h3 id="2-4-Summary"><a href="#2-4-Summary" class="headerlink" title="2.4 Summary"></a>2.4 Summary</h3><blockquote><p>Here we summarize 2.3 as follows:</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Attribute_mapping</span>(<span class="params">gdf, column, legend_kwds</span>):</span></span><br><span class="line">    ax = gdf.plot(figsize = (<span class="number">10</span>, <span class="number">10</span>), alpha = <span class="number">0.5</span>, edgecolor = <span class="string">&#x27;w&#x27;</span>, column = column, legend = <span class="literal">True</span>, legend_kwds = legend_kwds)</span><br><span class="line">    ctx.add_basemap(ax, url=ctx.providers.Stamen.TonerLite)</span><br><span class="line">    ax.set_axis_off()</span><br></pre></td></tr></table></figure><blockquote><p>Our input is:</p><ul><li><code>gdf</code> : Corresponding geopandas dataframe after processing in 2.2</li><li><code>column</code>: Corresponding Attribute column that we want to map</li><li><code>legend_kwds</code>: Corresponding legend parameters</li></ul></blockquote><p><strong>Let’s see an example below:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#First get our gdf</span></span><br><span class="line"><span class="keyword">import</span> geopandas <span class="keyword">as</span> gpd</span><br><span class="line">gdf = gpd.GeoDataFrame(df_merged, geometry = gpd.points_from_xy(df_merged.Lon, df_merged.Lat)) <span class="comment">#Note: df_merged is a pandas dataframe!</span></span><br><span class="line"><span class="comment">#process as in 2.2</span></span><br><span class="line"><span class="keyword">import</span> contextily <span class="keyword">as</span> ctx</span><br><span class="line">gdf.crs = &#123;<span class="string">&#x27;init&#x27;</span>: <span class="string">&#x27;epsg:4326&#x27;</span>, <span class="string">&#x27;no_defs&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">gdf = gdf.to_crs(epsg=<span class="number">3857</span>)</span><br><span class="line"><span class="comment">#set our column and legend_kwds</span></span><br><span class="line">column = <span class="string">&quot;Supply (MW)&quot;</span></span><br><span class="line">legend_kwds=&#123;<span class="string">&#x27;label&#x27;</span>: <span class="string">&quot;Supply (MW)&quot;</span>,<span class="string">&#x27;orientation&#x27;</span>: <span class="string">&quot;vertical&quot;</span>&#125;</span><br><span class="line"><span class="comment">#call the function above</span></span><br><span class="line">Attribute_mapping(gdf, column, legend_kwds)</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210164126937.png" alt="Third" style="zoom:67%;" /></p><hr><h2 id="3-Try-Something-More"><a href="#3-Try-Something-More" class="headerlink" title="3. Try Something More"></a>3. Try Something More</h2><h3 id="3-1-Remove-Zero"><a href="#3-1-Remove-Zero" class="headerlink" title="3.1 Remove Zero"></a>3.1 Remove Zero</h3><p>As we see the describe results in 1.2, more than 75% of Demand and Supply are all zero. So, in this part, we try to deal with them.</p><p>Just see the code</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">None_Zero_Demand = gdf[gdf[<span class="string">&#x27;Demand (MW)&#x27;</span>] != <span class="number">0.0</span>]</span><br><span class="line">None_Zero_Demand.head()</span><br><span class="line">None_Zero_Demand.describe()</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210165814250.png" alt="None0Demand" style="zoom:50%;" /><img src="/assets/image-20200210165930907.png" alt="Describe" style="zoom:50%;" /></p><p>Here we see:</p><ol><li>there are only 3095 none zero Demand compare to 14430 in total.</li><li>All the Supply  are zero while Demand are none zero</li></ol><h3 id="3-2-Visualize-the-None-Zero-Part"><a href="#3-2-Visualize-the-None-Zero-Part" class="headerlink" title="3.2 Visualize the None Zero Part"></a>3.2 Visualize the None Zero Part</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">column = <span class="string">&quot;Demand (MW)&quot;</span></span><br><span class="line">legend_kwds=&#123;<span class="string">&#x27;label&#x27;</span>: <span class="string">&quot;None Zero Demand&quot;</span>,<span class="string">&#x27;orientation&#x27;</span>: <span class="string">&quot;vertical&quot;</span>&#125;</span><br><span class="line">Attribute_mapping(None_Zero_Demand, column, legend_kwds)</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210170733776.png" alt="nonezerodemand" style="zoom:67%;" /></p><p>Though the points become less, most of them are near zero (purple color). So, we can try to limit the value to visualize more clear.</p><h3 id="3-3-Separate-into-Three-Parts-by-ordered-values"><a href="#3-3-Separate-into-Three-Parts-by-ordered-values" class="headerlink" title="3.3 Separate into Three Parts by ordered values"></a>3.3 Separate into Three Parts by ordered values</h3><p>Let’s first order the DataFrame by <code>Demand</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">None_Zero_Demand = None_Zero_Demand.sort_values(by = <span class="string">&#x27;Demand (MW)&#x27;</span>)</span><br><span class="line">None_Zero_Demand.head()</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210171813748.png" alt="order" style="zoom:67%;" /></p><p>Then split it into 3 parts</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Split3 = np.array_split(None_Zero_Demand, <span class="number">3</span>)</span><br><span class="line">Part1, Part2, Part3 = Split3[<span class="number">0</span>], Split3[<span class="number">1</span>], Split3[<span class="number">2</span>]</span><br><span class="line">Part1.head()</span><br><span class="line">Part2.head()</span><br><span class="line">Part3.head()</span><br><span class="line"><span class="comment">#Note: here the other two columns not presented in the figures</span></span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210172559313.png" alt="P1head" style="zoom:30%;" /><img src="/assets/image-20200210172638632.png" alt="P2head" style="zoom:30%;" /><img src="/assets/image-20200210172724404.png" alt="P3head" style="zoom:30%;" /></p><p>Finally, visualize each part</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">column = <span class="string">&quot;Demand (MW)&quot;</span></span><br><span class="line"><span class="comment">#Part1</span></span><br><span class="line">legend_kwds=&#123;<span class="string">&#x27;label&#x27;</span>: <span class="string">&quot;None Zero Demand&quot;</span>,<span class="string">&#x27;orientation&#x27;</span>: <span class="string">&quot;vertical&quot;</span>&#125;</span><br><span class="line">Attribute_mapping(Part1, column, legend_kwds)</span><br><span class="line"><span class="comment">#Part2</span></span><br><span class="line">legend_kwds=&#123;<span class="string">&#x27;label&#x27;</span>: <span class="string">&quot;None Zero Demand&quot;</span>,<span class="string">&#x27;orientation&#x27;</span>: <span class="string">&quot;vertical&quot;</span>&#125;</span><br><span class="line">Attribute_mapping(Part2, column, legend_kwds)</span><br><span class="line"><span class="comment">#Part3</span></span><br><span class="line">legend_kwds=&#123;<span class="string">&#x27;label&#x27;</span>: <span class="string">&quot;None Zero Demand&quot;</span>,<span class="string">&#x27;orientation&#x27;</span>: <span class="string">&quot;vertical&quot;</span>&#125;</span><br><span class="line">Attribute_mapping(Part3, column, legend_kwds)</span><br></pre></td></tr></table></figure><p><img src="/assets/image-20200210173434367.png" alt="P1V" style="zoom:30%;" /><img src="/assets/image-20200210173507904.png" alt="P2v" style="zoom:30%;" /><img src="/assets/image-20200210173536841.png" alt="P3v" style="zoom:30%;" /></p><p>Here we:</p><ul><li><p>[x] ​    Visualize three parts separately</p></li><li><p>[ ] ​    Unify the color bars in above three figures.</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Here we summarize the geospatial data visualization.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Synthetic Power Grid Data Set&lt;/code&gt;  will be used as an example. [&lt;a href=&quot;https://wimnet.ee.columbia.edu/portfolio/synthetic-power-grids-data-sets/&quot;&gt;Download here&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;Before all the things, let’s import some basic tools:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;%matplotlib inline&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.style.use(&lt;span class=&quot;string&quot;&gt;&amp;#x27;ggplot&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Notes" scheme="https://yihang-li.github.io/categories/Notes/"/>
    
    
      <category term="python" scheme="https://yihang-li.github.io/tags/python/"/>
    
      <category term="geospatial" scheme="https://yihang-li.github.io/tags/geospatial/"/>
    
      <category term="visualization" scheme="https://yihang-li.github.io/tags/visualization/"/>
    
  </entry>
  
</feed>
