---
title: Python相关知识点总结
tags: [summary]
---

# Python Summary

## Python的内存管理 [参考1](https://juejin.cn/post/6856235545220415496#heading-0) [参考2](https://www.jianshu.com/p/612542189db3?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)

Python作为一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言，与大多数编程语言不同，Python中的变量无需事先申明，变量无需指定类型，程序员无需关心内存管理，Python解释器给你自动回收。开发人员不用过多的关心内存管理机制，这一切全部由`python内存管理器`承担了复杂的内存管理工作。

python作为一种动态类型的语言，其`对象和引用分离`，这与面向过程的编程语言有很大的区别。为了有效的释放内存，python内置了垃圾回收的支持。python采用了一种相对简单的垃圾回收机制，即引用计数，并因此需要解决孤立引用环的问题。Python与其它语言既有共通性，又有特别的地方。对该内存管理机制的理解，是提高Python性能的重要一步。

### 内存如何释放

- `垃圾回收机制`：Python的垃圾回收机制采用`引用计数机制`为主，`标记-清除`和`分代回收机制`为辅的策略。

  - Python通过`引用计数`来保存内存中的变量追踪，即记录该对象被其他使用的对象引用的次数。

    Python中有个内部跟踪变量叫做引用计数器，每个变量有多少个引用，简称引用计数。当某个对象的引用计数为0时，就列入了垃圾回收队列。

  - `标记-清除`用来解决引用计数机制产生的循环引用，进而导致内存泄漏的问题 。 循环引用只有在容器对象才会产生，比如字典，元组，列表等。

    顾名思义，该机制在进行垃圾回收时分成了两步，分别是：

    - 标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达
    - 清除阶段，再次遍历对象，如果发现某个对象没有标记为可达（即为Unreachable），则就将其回收

  - `分代回收`是基于这样的一个统计事实: 对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度，是一种以空间换时间的方法策略。

    Python 将所有对象分为0、1、2三代。在第0代的gc扫描中存活下来的对象被移至第1代，（1->2同理）

    ```python
    >>> import gc 
    >>> gc.get_threshold() ## 分代回收机制的参数阈值设置
    (700, 10, 10)
    ```

    Note:

    - 700=新分配的对象数量-释放的对象数量，第0代gc扫描被触发
    - 第一个10：第0代gc扫描发生10次，则第1代的gc扫描被触发
    - 第二个10：第1代的gc扫描发生10次，则第2代的gc扫描被触发

- `内存池机制`

  Python语言虽然提供了对内存的垃圾回收机制，但实际上它将不用的内存放到内存池而不是返回给操作系统，所以就有了以下：

  - `Pymalloc机制`；这个主要是为了加速Python的执行效率，Python引入了一个内存池机制，用于管理，为了对小块内存的申请和释放。
  - Python中所有小于256个字节的对象都是依靠pymalloc分配器来实现的，而稍大的对象用的则是`系统的malloc`。
  - 对于Python`对象`，比如整数、浮点数和List这些，都有自己`独立的内存池`，对象间并不共享他们的内存池。换句话说就是，假设你分配并且释放了大量的整数，那么用于缓存这些整数的内存就不能再分配给浮点数。

## 深拷贝、浅拷贝 [参考](https://blog.csdn.net/weixin_45081575/article/details/104603779)

- **浅拷贝**：只拷贝数据集合最外边的一层，深层的数据只是做了内存地址引用，并没有拷贝。

- **深拷贝**：完全拷贝数据集合的所有数据，与源数据再无相关

- 注：

  - 可变对象：可变对象可以在其 id() 保持固定的情况下改变其取值；
  - 不可变对象：具有固定值的对象。不可变对象包括数字、字符串和元组。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。
  - id(object)： 函数用于获取对象的内存地址，函数返回对象的唯一标识符，标识符是一个整数。

- 个人理解：

  - 可变对象：通俗点讲就是一个对象在修改它的值时候，不会改变该对象所指向的内存地址。

  - 不可变对象：与可变对象相反。

  - 浅拷贝：浅拷贝只是复制外围的一层数据，内部的数据只是引用了原来的内存地址

  - 深拷贝：对外围和内部元素都进行了拷贝对象本身，而不是对象的引用

  - **不可变类型数据没有所谓的深浅拷贝**，都是对源对象内存地址的引用、赋值也是对内存地址的引用。

- == 与 is

  Python的 **==** 是判断两个对象的`值是否相等`，**is**则是判断两个对象的`内存地址是否相等`。



## Python装饰器 [参考](https://zhuanlan.zhihu.com/p/101687008) [参考2](https://zhuanlan.zhihu.com/p/137111413)

Python中的装饰器，**本质上就是一个高阶函数**（类比高阶导数），函数的函数（导数的导数）

- 可以**在不修改函数内部代码的前提下，为它包装一些额外的功能。**

  ```python
  def wrapexp(func):
      def wrapper(*args, **kwargs):
          print('this is a wrapper')
          func(*args, **kwargs)
      return wrapper
  
  @wrapexp
  def exp(a, b, c='hello', d='word'):
      print(a, b, c, d)
  
  
  args = [1997, 0]
  dt = {'c': 8, 'd': 28}
  
  exp(*args, **dt)
  ```

  

- 但是**一些基础的信息其实已经丢失了。**i.e. 不仅仅是\_\_name\_\_，函数内部还有很多其他的基本信息，比如记录函数内描述的\_\_doc\_\_，\_\_annotations\_\_等等，这些基本信息被称为是**元信息**，这些元信息由于我们使用注解发生了丢失。

  - Python当中为我们**提供了一个专门的装饰器**用来保留函数的元信息，我们只需要在实现装饰器的wrapper函数当中加上一个注解wraps即可。

    ```python
    from functools import wraps
    def wrapexp(func):
        @wraps(func) ##here add the wraps to keep meta info.
        def wrapper(*args, **kwargs):
            print('this is a wrapper')
            func(*args, **kwargs)
        return wrapper
    @wrapexp
    def exp(a, b, c='hello', d='word'):
        print(a, b, c, d)
    
    print(exp.__name__)
    ```

    



## Numpy相关

待补充

## Pytorch相关

### P ytorch是Facebook开源的深度学习框架

- `基本要素`: 包括tensor（张量）、 Pytorch Numpy、数学运算、自动分级模块、优化模块、nn模块等
  - `tensor（张量）`: Pytorch整个框架是基于tensor的，tensor 是可以在GPU上运行的n维数组（类似ndarray）（如果想要在GPU上运算，就需要把tensor换成cuda类型）

